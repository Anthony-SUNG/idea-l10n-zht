flash.module.type.name=Flash 模塊
flash.module.type.description=Flash 模塊旨在用於開發以 <b>Adobe Flash</b> 平台為目標的內容。<br>利用該模塊提供的構建配置，您可以為 web (Flash Player)、桌面 (Adobe AIR) 和 AIR 移動平台創建 <b>Flex</b> 或純 <b>ActionScript</b> 應用程序和庫。

debugger.waiting.player=正在等待 AIR 或 Flash Player 連接
remote.flash.debug.computer=<html>調試器正在等待 Flash 應用程序連接:<br><ul><li>在此計算機上啟動 Flash 或 AIR 應用程序。它將自動連接到調試器。</li><li>或右鍵點擊此計算機或遠端計算機上正在運行的 Flash Player，然後從上下文選單中選擇“調試器”。</li></ul>此計算機的 IP 地址: {0}</html>
remote.flash.debug.mobile.network=<html>在 {0} 設備上啟動移動 AIR 應用程序以開始調試。<br>(必須打包該應用程序，才能通過網絡進行調試)。<br><br>此計算機的 IP 地址: {1}</html>
remote.flash.debug.mobile.usb=<html>在 {0} 設備上啟動移動 AIR 應用程序以開始調試。<br>(必須打包該應用程序，才能通過 USB 進行調試，端口 {1})。
initializing.flex.debugger=初始化 Flex 調試器
flex.debugger.startup.error=Flex 調試器啟動錯誤
flex.debugger.unexpected.communication.error=意外的調試播放器通信問題

must.accompany.includein.or.excludefrom.attribute={0} 必須伴隨 includeIn 或 excludeFrom 特性。
flex.invalid.enumeration.value={0} 不在可接受的枚舉值內
flex.break.point.title=Flex 斷點
flex.invalid.integer.value=整數值無效
flex.invalid.number.value=數值無效

no.file.to.run=找不到 HTML 包裝器或 SWF 檔案來開始運行/調試
remote.url.is.not.accessible.title=遠端 URL 不可訪問
remote.url.is.not.accessible.message=嘗試提取 ''{0}'' 時遇到以下 IO 異常: \n{1}\n要繼續嗎?
flex.run.config.url.can.not.be.run.with.flash.player=無法使用 Flash Player 啟動 URL
html.wrapper.can.not.be.run.with.flash.player=無法使用 Flash Player 啟動 HTML 包裝器
path.to.flash.player.not.set=未設定 Flash Player 的路徑('Launch with' 選項)
flash.player.not.found=找不到 Flash Player 可執行檔案: {0}
run.trusted=將輸出資料夾放到本地信任沙盒中(&E)
flex.run.config.incorrect.url=URL 不正確
flex.run.config.url.not.set=未設定要啟動的 URL 或檔案
debugger.sdk.not.found=找不到 SDK: {0}
file.not.found=找不到檔案: {0}
main.class.not.set=未指定主類
main.class.not.found=找不到主類 ''{0}''
rlm.main.class.not.set=未指定運行時加載模塊的主類。
rlm.main.class.not.found=找不到運行時加載模塊的主類: {0}
rlm.main.class.equal.to.bc.main.class=運行時加載模塊的主類等於主應用程序類：''{0}''
rlm.output.equal.to.bc.output=運行時加載模塊的輸出檔案等於主應用程序的輸出檔案: ''{0}''
output.file.name.not.specified=未指定輸出文件名。
rlm.output.file.name.not.specified=未指定運行時加載模塊的輸出檔案。
output.file.must.have.swf.extension=輸出檔案必須有 swf 擴展名。
rlm.output.file.must.have.swf.extension=運行時加載模塊的輸出檔案必須有 swf 擴展名。
flex.sdk.version.unknown=未知版本
popup.title.step.into.function=單步進入函數
sdk.can.not.be.selected=無法在此處選擇 SDK ''{0}''。\n請選擇 Flex/AIR SDK。
select.flex.sdk=選擇 Flex/AIR SDK
cannot.resolve.state=狀態引用無效
configuration.not.valid=運行配置錯誤: {0}
module.not.specified=未指定模塊
module.not.found=找不到模塊 ''{0}''
flexunit.not.found.for.bc=構建配置 ''{0}'' 的依賴項不包括 FlexUnit 庫
no.test.method.specified=未指定測試方法
method.not.valid=方法 ''{0}'' 不存在或不適合在測試中運行
package.not.valid=缺少 ''{0}'' 軟件包或此軟件包為空
class.not.public=''{0}'' 不為 public
class.not.specified=未指定類
test.class.not.specified=未指定測試類
class.not.found=未找到類 ''{0}''
class.contains.no.tests=類 ''{0}'' 不包含測試
tests.in=''{0}'' 中的測試
no.free.port=找不到空閒端口
flexunit.startup.error=無法啟動 FlexUnit 會話: {0}
port.is.busy=端口 {0} 繁忙

flexunit.inspections.group=FlexUnit
flexunit.inspection.testclassvisibility.displayname=測試類不為 public
flexunit.inspection.testmethodvisibility.displayname=測試方法不為 public
flexunit.inspection.testclassvisibility.message=測試類應為 public
flexunit.inspection.testmethodvisibility.message=測試方法應為 public
flexunit.inspection.testmethodisstatic.displayname=測試方法為 static
flexunit.inspection.testmethodisstatic.message=測試方法不應為 static
flexunit.fix.remove.static.modifier=移除 static 修飾符
flexunit.inspection.testmethodisproperty.displayname=測試方法為 getter/setter
flexunit.inspection.testmethodisproperty.message=測試方法不應為 getter 或 setter
flexunit.inspection.testmethodhasparameters.displayname=測試方法具有必需參數
flexunit.inspection.testmethodhasparameters.message=測試方法不應具有必需參數
flexunit.inspection.testmethodreturntype.displayname=測試方法應返回 void
flexunit.inspection.testmethodreturntype.message=測試方法應返回 void
flexunit.inspection.mixedapi.displayname=擴展 FlexUnit 1 或 Flunit TestCase 的類中的 FlexUnit 4 測試方法
flexunit.inspection.mixedapi.message=擴展 FlexUnit 1 或 Flunit TestCase 的類中的 FlexUnit 4 測試方法
flexunit.inspection.testclassinproductsource.displayname=產品源中的測試類
flexunit.inspection.testclassinproductsource.message=產品源中的測試類
flexunit.inspection.testclasswithnotests.displayname=測試類沒有測試
flexunit.inspection.testclasswithnotests.message=測試類沒有測試
flexunit.inspection.runnerclass.displayname=自定義運行程序類實現 IRunner 接口
flexunit.inspection.runnerclass.message=類未實現 IRunner 接口
flexunit.inspection.testmethodinsuite.message=測試方法位於套件中
flexunit.inspection.testmethodinsuite.displayname=測試方法位於套件中
flexunit.inspection.emptysuite.message=測試套件為空
flexunit.inspection.emptysuite.displayname=測試套件為空
flexunit.inspection.suitewithnorunner.displayname=測試套件未指定運行程序類
flexunit.inspection.suitewithnorunner.message=測試套件未指定運行程序類
flexunit.test.runner.caption=FlexUnit 測試運行程序
invalid.flex.compiler.heap.size=Flex 編譯器堆大小無效
fcsh.out.of.memory.and.restarted=Flex 編譯器 shell 內存不足，將重啟。在“{0} | 編譯器 | Flex 編譯器”頁面可以增加其堆大小
compiling.module=正在編譯模塊 ''{0}''…
unnamed=未命名
js.actionscript.specific.group.name=ActionScript 特定
js.implicitly.internal.declaration.inspection.name=具有隱式訪問類型的聲明
js.implicitly.internal.declaration.problem=聲明具有隱式軟件包內部範圍 #loc
js.implicitly.internal.declaration.problem.add.internal.fix=添加顯式 internal 修飾符
js.untyped.declaration.inspection.name=沒有類型的聲明
js.untyped.variable.problem=變量 {0} 沒有類型 #loc
js.untyped.function.problem=函數 {0} 沒有返回類型 #loc
js.untyped.declaration.problem.addtype.fix=向聲明中添加類型
js.field.can.be.local.name=字段可以為本地字段
js.field.can.be.converted.to.local=字段可以被轉換為一個局部變量
js.convert.to.local.quick.fix=轉換為本地

flash.builder=Flash Builder
flash.builder.project.import.title=Flash Builder 項目導入
sdk.for.imported.projects=所導入的 Flash Builder {0, choice, 1#項目|2#項目}的 SDK: 
flash.builder.workspace.or.project.dir=Flash Builder 工作區或項目，*.fxp、*.fxpl 或 *.zip 檔案(&F)
select.flash.builder.workspace.or.project=選擇 *.fxp、*.fxpl 或 *.zip 檔案、Flash Builder 工作區或項目
specify.flash.builder.workspace.or.project.dir=未設定檔案或資料夾路徑
dialog.title.import.from.flash.builder=從 Flash Builder 導入 {0}
folder.not.empty=資料夾不為空: \n{0}\n某些檔案可能會被覆蓋。\n\n是否繼續?
folder.does.not.exist=資料夾不存在: ''{0}''
file.or.folder.not.found=找不到檔案或資料夾: {0}
flash.builder.projects.not.found.in=在所選資料夾中找不到 Flash Builder 項目
not.flash.builder.project=所選檔案不是 Flash Builder 項目
does.not.contain.flash.builder.projects=所選歸檔不包含 Flash Builder 項目
incorrect.file.format=所選歸檔的格式不正確
folder.to.unzip.one.FB.project=將項目提取到
folder.to.unzip.several.FB.projects=找到多個項目。將它們提取到以下項目的對應子資料夾:
note.multiple.projects.extract.to.subfolders=注意: 找到多個項目。它們將被提取到對應的子資料夾。
extract.single.to.subfolder.0=為提取的項目創建子資料夾 ''{0}''
project.location=項目位置
project.files.location=項目檔案位置
open.project.0=打開項目 ''{0}''
failed.to.extract.project=無法提取項目: \n{0}
project.name.empty=項目名稱不能為空
project.path.empty=項目檔案的位置不能為空
looking.for.flash.builder.projects=正在尋找 Flash Builder 項目

adl.not.set.check.sdk.settings=未設定 AIR Debug Launcher。檢查 SDK ''{0}'' 的配置
adl.not.found.check.sdk.settings=在 ''{0}'' 處找不到 AIR Debug Launcher。檢查 SDK ''{1}'' 的配置
adl.not.found.check.sdk.installation=在 ''{0}'' 處找不到 AIR Debug Launcher。檢查 SDK ''{1}'' 的安裝
air.runtime.not.set.check.sdk.settings=未設定 AIR 運行時。檢查 SDK ''{0}'' 的配置
air.runtime.not.found.check.sdk.settings=在 ''{0}'' 處找不到 AIR 運行時。檢查 SDK ''{1}'' 的配置
checking.url=正在檢查 URL ''{0}''
bad.url=錯誤的 URL: {0}
no.response.from.server={0} 秒內伺服器無響應
choose.event.class.title=選擇事件類
compilation.skipped.because.nothing.changed.in=自上次編譯以來，模塊 ''{0}'' 中沒有進行過任何更改。跳過…\n點擊“構建”選單中的“重新構建項目”以強制進行編譯。
compilation.skipped.because.nothing.changed=自上次編譯以來沒有進行過任何更改。跳過…\n點擊“構建”選單中的“重新構建項目”以強制進行編譯。
compilation.skipped=已跳過編譯
dumb.mode.flex.unit.warning=更新索引時無法運行 FlexUnit 測試。構建索引後，請再次執行此運行配置。
debugger.show.full.value=查看
breakpoint.condition.error=斷點條件錯誤
failed.to.evaluate.breakpoint.condition=無法評估斷點條件: {0}\n\n要在斷點處停止嗎?
not.boolean.breakpoint.condition=無法評估斷點條件: {0}\n結果值不是布爾值: {1}\n\n要在斷點處停止嗎?

error.creating.flash.player.trust.folder=SWF 檔案未添加到本地信任沙盒\n無法創建 FlashPlayerTrust 資料夾: {0}
flash.player.trust.folder.does.not.exist=SWF 檔案未添加到本地信任沙盒\nFlashPlayerTrust 資料夾不存在
error.creating.idea.trust.cfg.file=SWF 檔案未添加到本地信任沙盒\n無法在 FlashPlayerTrust 資料夾中創建 {0} 檔案: {1}
could.not.find.swf.to.trust=找不到要添加到本地信任沙盒的 SWF 檔案
failed.to.update.idea.trust.cfg.file=無法更新 FlashPlayerTrust 資料夾中的 {0} 檔案: {1}

file.created=已創建 <a href="">{0}</a>
html.wrapper.creation.failed=無法創建 HTML 包裝器\n{0}
error.title=錯誤

root.tag.must.contain.language.namespace=根標記必須包含語言命名空間聲明
different.language.namespaces=在 MXML 檔案中聲明了不同的語言命名空間
remove.namespace.declaration=移除命名空間聲明
declare.namespace=聲明命名空間 {0}
flex.choose.color.dialog.title=選擇顏色
system.default.application=系統預設應用程序
launch.with.title=啟動方式
cant.launch=無法使用 {1}\n打開 {0}\n錯誤: {2}
css.files.title=要編譯為 SWF 的 CSS 檔案

livetemplate.description.iter=迭代 (for each..in)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.itar=遍歷數組元素
livetemplate.description.ritar=反序遍歷數組元素

create.skin=創建皮膚 ''{0}''
invalid.element.name=無效 {0} 名稱: {1}
element.name.empty={0} 名稱為空
choose.host.component=選擇主機組件
css.inspections.stray.brace=Flex CSS 中的雜散大括號
css.inspections.stray.closing.brace=右大括號沒有對應的左大括號
css.inspections.stray.opening.brace=左大括號沒有對應的右大括號
choose.parent.component.dialog.title=選擇父組件
intention.create.subclass.or.implement.interface=創建子類或實現接口
intention.create.event.handler=創建事件處理程序

threads=線程
processes=進程
using.builtin.compiler=使用內置的編譯器 shell，最多 {0} 個並行線程
using.mxmlc.compc=使用 Flex SDK 中的 mxmlc/compc 工具，最多 {0} 個並行進程
or.asc.2.0=，或 ASC 2.0(如果可用)，用於純 ActionScript 構建配置
see.flex.compiler.page=在“{0} | 編譯器 Flex 編譯器”頁面中查看編譯器設定
can.not.use.built.in.compiler.shell=無法使用內置的編譯器 shell，原因是為不同的構建配置配置了不同的 Flex SDK。

add.doc.url.button=添加文檔 URL

generating.flex.configs=正在生成 Flex 編譯器配置檔案
generating.flex.config.for=正在為 {0} 生成 Flex 編譯器配置檔案
flexmojos.warning.short=<html>無法生成 Flex 編譯器配置檔案。<br><a href="">詳細信息…</a></html>
flexmojos.warning.detailed=<html><p>IntelliJ IDEA 無法生成 <b>Flex 編譯器配置檔案</b>和其他輔助檔案<br>(target/[project_name]-config-report.xml and target/classes/config-[version]/*.*)</p><br><p>這些檔案對於 Flexmojos 項目中的正確代碼高亮顯示、補全和編譯而言必不可少。<br>要確保所需檔案處於最新狀態，請從命令行運行以下 Maven 命令: </p><pre><b>mvn compile -DconfigurationReport=true</b></pre></html>

flexmojos4.details.start=日誌中提供了完整的信息(幫助 | 顯示日誌)\n\n{0}
flexmojos4.warning=無法生成 Flex 編譯器配置檔案。\n{0}
flexmojos4.warning.with.link=<html>無法生成 Flex 編譯器配置檔案。<br><a href="">詳細信息…</a></html>
flexmojos.maven.plugin.outdated.warning=請從您的 POM ({0})中移除過時的 idea-flexmojos-maven-plugin

flexmojos.project.import=Flexmojos 項目導入
run.when.ide.builder.turned.off=<html>為<a href="BuildConfiguration">構建配置 ''{0}''</a>(模塊 ''{1}'')設定了“跳過編譯”標誌。<br>啟動的應用程序可能丟失或已過時。<br><br><a href="DisableWarning">禁用警告</a></html>
run.when.compile.before.run.turned.off=<html>此<a href="RunConfiguration">運行配置</a>的“啟動前構建”選項已關閉。<br>啟動的應用程序可能丟失或已過時。<br><br><a href="DisableWarning">禁用警告</a></html>
flex.sdk.3.mac.debug.problem=<html>Flex SDK {0} 中的調試器不適用於 Flash Player11.x。<br/>建議在<a href="RunConfiguration">運行配置</a>的“使用 SDK 中的調試器”字段選擇 Flex SDK 4.x。
edit.configuration.title=編輯配置
replace.base.component.prompt=將基礎組件 ''{0}'' 替換為 ''{1}''?
replace.base.class.prompt=將基類 ''{0}'' 替換為 ''{1}''?
create.edge.title=創建邊緣
create.extends.relationship.command.name={0} 擴展 {1}
create.implements.relationship.command.name={0} 實現 {1}
base.component.needed.message=無法移除與基礎組件的關係
remove.edge.title=移除邊緣
remove.inheritance.link.prompt=移除 ''{0}'' 與 ''{1}'' 之間的繼承鏈接?
remove.relationship.command.name=移除繼承關係
move.0=移動 {0} {1}
move.file.local.0=移動內部{0}{1}
move.elements=移動指定的元素
move.command.name=將 {0} 移至 {1}
element.to.be.moved.to={0} 將被移至 {1}
elements.to.be.moved.to=元素將被移至{0}
references.in.code.to.0=在代碼中引用到{0}
package.name.title=軟件包名稱:
to.package.title=到軟件包:
element.to.be.moved.to.upper.level=內部{0}將被移至上一個級別({1})
move.to.upper.level.command.name=將內部{0}移至{1}
references.in.code.to.inner.0=代碼中對內部{0}的引用
element.name={0} 名稱(&N):
android.application.launched=在設備上啟動的 Android 應用
ios.application.packaged.to.run=<html>iOS 應用程序軟件包 <a href="">{0}</a> 已成功創建。<br>您現在可以使用 iTunes 將其安裝在設備上。</html>
ios.application.packaged.to.debug=<html>iOS 應用程序軟件包 <a href="">{0}</a> 已成功創建。<br>您現在可以使用 iTunes 在設備上進行安裝。<br><br>調試器正在等待在該設備上啟動應用程序…</html>
ios.application.installed.to.run=已成功安裝 iOS 應用程序 ''{0}''，\n現在您可以在設備上啟動它了。
ios.application.installed.to.debug=已成功安裝 iOS 應用程序 ''{0}''，\n現在您可以在設備上啟動並開始調試了。
ios.simulator.application.launched=在 iOS 模擬器上啟動的應用程序

css.flex.dialect.name=Flex
unexpected.empty.adt.output=ADT 工具無輸出
air.mobile.version.problem.title=AIR 版本
air.ios.debug.via.usb.requires.3.4=要通過 USB 調試 iOS 應用程序，需要使用 <b>AIR 3.4 或更高版本</b>。
air.ios.simulator.requires.3.3=要在 iOS 模擬器上運行應用程序，需要使用 <b>AIR 3.3 或更高版本</b>。
air.captive.packaging.requires.3.0=要使用 captive runtime 創建 AIR 軟件包，需要使用 <b>AIR 3.0 或更高版本</b>。
air.mobile.ios.fast.packaging.requires.2.7=要在解釋器模式(快速打包)下創建 iOS 軟件包，需要使用 <b>AIR 2.7 或更高版本</b>。
air.mobile.packaging.requires.2.6=要創建 AIR 移動軟件包，需要使用 <b>AIR 2.6 或更高版本</b>。
air.mobile.packaging.version.problem=<html>{0}<br><br>SDK ''{1}'' 包含 AIR {2}。<br>您可以執行下面的一項操作:<ul><li>在當前使用的 Flex SDK 上解壓縮 AIR SDK {3} 或更高版本</li><li>使用已包含 AIR {3} 或更高版本的 Flex SDK 的另一個版本</li></ul></html>
launch.android.application.title=啟動 Android 應用
launching.android.application=啟動 Android 應用 {0}
launch.ios.application.title=啟動 iOS 應用程序
launching.ios.application=啟動 iOS 應用程序 {0}
adb.forward.title=ADB 前向
check.ios.devices.title=檢查 iOS 設備
checking.ios.devices=正在檢查 iOS 設備
more.than.one.ios.device=多台 iOS 設備已連接到計算機
idb.forward=IDB 前向
idb.forward.title=IDB 前向
packaging.application=打包 {0} 應用程序
air.application.created=創建的 <html>AIR {0, choice, 1#應用程序|2#應用程序}: <br>{1}</html>
dialog.edit.template.checkbox.mxml=MXML(&M)
air.runtime.version.title=AIR 運行時版本
air.runtime.not.installed=設備上未安裝 AIR 運行時。\nSDK ''{0}'' 包含 AIR 運行時 {1}。\n\n要安裝嗎?
update.air.runtime.question=設備上已安裝 AIR 運行時 {0}。\nSDK ''{1} 包含 AIR 運行時 {2}。\n\n要安裝較新的版本嗎?
check.air.version.title=檢查 AIR 版本
checking.air.version=正在檢查 AIR 版本
uninstall.air.runtime.title=解除安裝 AIR 運行時
uninstalling.air.runtime=正在解除安裝 AIR 運行時
install.air.runtime.title=安裝 AIR 運行時
installing.air.runtime=正在安裝 AIR 運行時 {0}
create.android.package.title=創建 Android 軟件包
create.ios.package.title=創建 iOS 軟件包
creating.android.package=正在創建 Android 軟件包
creating.ios.package=正在創建 iOS 軟件包
install.android.application.title=安裝 Android 應用
install.ipa.on.simulator.title=在 iOS 模擬器上安裝應用程序
install.ios.app.title=安裝 iOS 應用程序
installing.0=正在安裝 {0}
uninstall.android.application.title=移除 Android 應用
uninstall.ios.simulator.application.title=從 iOS 模擬器移除應用程序
uninstalling.0=正在移除 {0}
clear.directive.state.specific.error='@Clear' 指令只能用於狀態特定的樣式屬性
clear.directive.IStyleClient.error=僅允許實現 mx.styles.IStyleClient 接口的類的樣式屬性使用 '@Clear()' 指令
unknown.color.error=未知顏色: ''{0}''
sdk.not.set=未設定 SDK
output.file.name.not.set=未設定輸出文件名
output.file.wrong.extension=輸出文件名必須有 {0} 擴展名
not.a.css.runtime.stylesheet=檔案 ''{0}'' 不能用作運行時樣式表，僅允許使用 CSS 檔案。
css.not.found=運行時樣式表: 檔案不存在: {0}
file.to.include.in.swc.not.found=要包含在 SWC 中的檔案: 檔案 ''{0}'' 不存在
output.folder.not.set=未設定輸出資料夾
flexunit.output.folder.not.set=未設定項目輸出資料夾或其路徑不是絕對路徑(FlexUnit 需要絕對路徑)
output.folder.not.absolute=輸出資料夾的路徑必須為絕對路徑: {0}
html.template.folder.not.set=未設定包含 HTML 包裝器模板的資料夾
html.template.folder.not.found=包含 HTML 包裝器模板的資料夾不存在: ''{0}''
package.file.name.not.set=未設定 {0} 軟件包文件名
packaging.options.empty.file.name={0} 打包選項，要打包的檔案: 表中的路徑為空
packaging.options.empty.relative.path={0} 打包選項，要打包的檔案: 表中的相對路徑為空
folder.to.package.includes.output={0} 打包選項: 要打包的資料夾包含輸出資料夾: {1}
packaging.options.bad.ios.sdk.path={0} 打包選項: 在 {1} 下找不到 iOS SDK
ios.provisioning.profile.not.set=未設定 iOS 預置配置檔案
ios.provisioning.profile.not.found=找不到 iOS 預置配置檔案: {0}
keystore.not.set={0} 簽名選項: 未設定密鑰庫
keystore.not.found={0} 簽名選項: 找不到密鑰庫檔案: {1}
packaging.options.relative.path.not.matches={0} 打包選項，要打包的檔案: 相對資料夾路徑與其完整路徑不匹配: {1}
packaging.options.file.not.found={0} 打包選項，找不到檔案: {1}
additional.config.file.not.found=找不到其他編譯器配置檔案: {0}
bc.dependency.problem=發現禁止的依賴項: \n構建配置 ''{0}'' ({2}，模塊 ''{1}'')\n依賴於構建配置 ''{3}'' ({5}，模塊 ''{4}'')。\n依賴項類型: {6}
run.configuration.0=運行配置 ''{0}''
project.setup.problem=項目設定問題: {0}
project.setup.problem.title=項目設定問題
bc.dependency.does.not.exist=構建配置 ''{0}'' (模塊''{1}'')不存在。\n設定為構建配置 ''{2}'' (模塊 ''{3}'')的依賴項
bc.not.specified=未指定構建配置
module.does.not.contain.bc=模塊 ''{0}'' 不包含構建配置 ''{1}''
bc.does.not.produce.app=構建配置 ''{0}'' (模塊 ''{1}'')不會生成可運行的應用程序
android.disabled.in.bc=未在構建配置 ''{0}'' (模塊 ''{1}'')中啟用 Android 支援
ios.disabled.in.bc=未在構建配置 ''{0}'' (模塊 ''{1}'')中啟用 iOS 支援
bc.0.module.1.android.custom.descriptor.not.set=構建配置 ''{0}'' (模塊 ''{1}''):\n未設定自定義 Android 應用描述符路徑
bc.0.module.1.ios.custom.descriptor.not.set=構建配置 ''{0}'' (模塊 ''{1}''):\n未設定自定義 iOS 應用描述符路徑
bc.0.module.1.custom.descriptor.not.set=構建配置 ''{0}'' (模塊 ''{1}''):\n未設定自定義應用描述符路徑
bc.0.module.1.android.custom.descriptor.not.found=構建配置 ''{0}'' (模塊 ''{1}''): \n找不到自定義 Android 應用描述符:\n{2}
bc.0.module.1.ios.custom.descriptor.not.found=構建配置 ''{0}'' (模塊 ''{1}''): \n找不到自定義 iOS 應用描述符:\n{2}
bc.0.module.1.custom.descriptor.not.found=構建配置 ''{0}'' (模塊 ''{1}''):\n找不到自定義應用描述符: \n{2}
bc.0.module.1.air.version.mismatch.warning=構建配置 ''{0}'' (模塊 ''{1}''):<br>應用描述符中的 AIR 版本({2})與 AIR SDK 版本不匹配: {3}。<br>{4}
custom.descriptor.not.set=未設定自定義 {0} 應用描述符路徑
custom.descriptor.not.found=找不到自定義 {0} 應用描述符: {1}
air.version.mismatch.warning=警告: {0} 應用描述符 {1} 中的 AIR 版本({2})與 AIR SDK 版本不匹配: {3}
same.output.files=輸出檔案與構建配置 ''{0}'' (模塊 ''{1}'')中的相同: {2}
same.output.files.as.in.bcs=輸出檔案與構建{0, choice, 1#配置|2#配置} {1} 相同: {2}
sdk.does.not.support.air.mobile=Flex SDK {0} 不支持 AIR 移動開發
sample.app.name.empty=未指定示例應用程序文件名
sample.app.incorrect.extension=示例應用程序必須具有 .mxml 或 .as 檔案擴展名
failed.to.create.folder=無法創建資料夾 {0}: \n{1}
create.html.wrapper.template.title=創建 HTML 包裝器模板
selected.path.not.folder=所選路徑不是資料夾: \n{0}
folder.not.empty.clear.or.overwrite=所選資料夾不為空。\n要移除其內容還是保留現有檔案(在後一種情況下，某些檔案可能會被覆蓋)?
folder.not.empty.clear.option=移除(&R)
folder.not.empty.keep.option=保持(&K)
folder.not.empty.cancel.option=取消(&C)
failed.to.delete=無法移除檔案: \n{0}
html.wrapper.in.sdk.not.found=在 SDK 安裝中找不到包含 HTML 包裝器模板的資料夾: \n{0}
create.air.descriptor.template.title=創建 AIR 描述符模板
use.same.descriptor.for.android.and.ios=要將創建的 AIR 描述符模板用於 Android 和 iOS 打包嗎?
file.exists.replace.question=要替換現有檔案({0})嗎?
default.compiler.options.for.module.title=模塊 ''{0}'' 的預設編譯器選項
default.compiler.options.for.project.title=項目 ''{0}'' 的預設編譯器選項
overridden.in.config.file={0} 被其他編譯器配置檔案覆蓋。實際值: {1}
main.class.and.output.overridden.in.config.file=主類和輸出路徑在其他編譯器配置檔案中被覆蓋
actual.value.from.config.file.0=配置檔案中的實際值: {0}
set.up.sdk.title=設定構建配置 SDK
choose.build.configuration.popup.title=模塊 ''{0}'' 的有效 Flash 構建配置
active.bc.widget.tooltip=Flash 構建配置 ''{0}'' 用於模塊 ''{1}'' 中的原始碼高亮顯示和補全
active.bc.widget.empty.tooltip=<html>此窗格顯示了上下文中該模塊的有效 Flash 構建配置。<br>有效構建配置用於高亮顯示和補全原始碼。</html>
active.bc.widget.empty.text=Flash 構建配置
flex.sdk.presentable.name=Flex/AIR SDK
add.build.configuration.title=添加構建配置(模塊 ''{0}'')
copy.build.configuration=複製構建配置 ''{0}'' (模塊 ''{1}'')
build.configurations.popup.separator.text=構建配置
module.sdk.label=模塊 SDK(&S):
project.sdk.label=項目 SDK(&S):
bc.0.module.1.problem.2=構建配置 ''{0}'' (模塊 ''{1}''): {2}
bc.tab.general.display.name=常規
bc.tab.dependencies.display.name=依賴項
bc.tab.compiler.options.display.name=編譯器選項
bc.tab.air.desktop.display.name=AIR 軟件包
bc.tab.android.display.name=Android
bc.tab.ios.packaging.display.name=iOS
bc.problem.no.sdk=未定義 SDK。
bc.problem.sdk.not.found=找不到 Flex SDK ''{0}''。
bc.problem.dependency.module.not.found=缺少依賴項模塊 ''{0}''。
bc.problem.dependency.bc.not.found=模塊 ''{1}'' 中缺少依賴項構建配置 ''{0}''。
bc.structure.element.type.name=構建配置
can.not.package.bc=<html><b>{0}</b>: {1}</html>
package.bc.with.disabled.compilation=<html>為以下構建{0, choice, 1#配置|2＃配置} 禁用編譯: <br><br>{1}<br>現有 SWF {0, choice, 1#檔案|2#檔案} 可能已過時。<br><br>根據現有的SWF {0, choice, 1#檔案|2#檔案} 創建{0, choice, 1#軟件包|2#軟件包}?</html>
package.air.application.title=打包 AIR 應用程序
packaging.air.application=正在打包 AIR 應用程序: {0}
failed.to.create.air.package=<html>無法打包 AIR 應用程序 {0}: <br><br>{1}<br><br>[<a href="adt.command.line">ADT 命令行</a>]</html>
failed.to.create.air.package.truncated=<html>無法打包 AIR 應用程序 {0}: <br><br>{1}<br><br>[<a href="full.error.message">完整錯誤消息</a>]<br>[<a href="adt.command.line">ADT 命令行</a>]</html>
copying.0=正在複製 {0}…
add.bc.dependency.dialog.title=添加依賴項
add.dependency.bc.dialog.label=選擇要依賴的構建配置:
no.applicable.bcs=找不到適用的構建配置
choose.bc.dialog.title=選擇 Flash 構建配置
choose.bc.dialog.label=庫 ''{0}'' 將添加到所選構建配置:
swc.libraries.root.detector.name=SWC 或 ANE 庫
docs.root.detector.name=文檔
as.libraries.root.detector.name=原始 ActionScript 庫
sources.root.detector.name=庫原始碼
swc.folders.root.detector.name=包含 SWC 或 ANE 的資料夾
add.module.library.action.text=新建庫…
documentation.order.root.type.name=文檔
items.to.include.in.swc.dialog.title=要包含在 SWC 中的檔案和資料夾
rlms.dialog.title=運行時加載的模塊
choose.rlm.main.class.title=選擇運行時加載的模塊的主類
css.files.to.compile.dialog.title=要編譯的 CSS 檔案
different.debug.settings=無法同時為  {0, choice, 1#Android |2#iOS} 創建可調試軟件包，也無法同時為  {0, choice, 1#Android |2#iOS} 創建不可調試軟件包
compilation.is.switched.off=編譯已關閉且輸出 SWF 不存在
main.class.is.not.a.subclass.of=主類 ''{0}'' 不是 {1} 的 public 子類。
change.bc.type.title=更改構建配置類型
bc.dialog.up.down.tooltip=使用上下鍵更改目標平台，按住 Shift 鍵更改輸出類型
check.flash.app.compiled.before.launch.notification.group=啟動前未編譯 Flash 應用
0.module.1=''{0}'' (模塊 ''{1}'')
open.project.structure=項目結構…
autodetected.source.root.type=ActionScript/Flex
create.bc.action.text=Flash 構建配置
create.bc.action.description=新建 Flash 構建配置
library.editor.title.plural=庫
library.editor.title.singular=庫
make.before.launch.warning.disabled=已禁用有關跳過編譯的警告。\n要再次啟用，請使用“事件日誌”工具視窗中的“設定”按鈕。
sdk.version.unknown=無法讀取 SDK ''{0}'' 的版本。確保 [SDK 主頁]/flex-sdk-description.xml (或 [SDK 主頁]/air-sdk-description.xml)檔案未損壞，然後嘗試重新創建 SDK
air.sdk.requires.pure.as=構建配置應標記為“純 ActionScript”，因為 AIR SDK ''{0}'' 不包含 Flex 組件
html.wrapper.folder.clash=包含 HTML 包裝器模板的資料夾與 {0} 衝突: {1}
html.wrapper.folder.clash.for.dialog=路徑與 {0} 衝突: {1}
take.wrapper.template.from.sdk=從以下 Flex/AIR SDK 中獲取 HTML 包裝器模板(&T):
choose.library.files.description=<html>選擇 *.swc 或 *.ane 檔案和/或包含 *.swc、*.ane 或原始 ActionScript 檔案的資料夾。<br>{0} 將分析所選資料夾的內容，並自動將其中包含的檔案分配至適當的類別(類、原始碼和文檔)。</html>
add.shared.library.dependency.action.text=項目或全域類別庫…
add.dependency.popup.title=添加依賴關係:
add.dependency.action.name=添加依賴項
add.library.components.action.name=添加庫組件(&L)…
uml.calculating.dependencies.message=正在計算依賴項
uml.dependencies.one.to.one=一對一
uml.dependencies.one.to.many=一對多
uml.dependencies.usages=用法
uml.dependencies.self=自我鏈接
uml.dependencies.create=創建
own.lib.used.as.3rd.party=依賴於檢測到的檔案 {0}，即構建配置 ''{1}'' (模塊 ''{2}'')的輸出。更為典型的情況是，一個構建配置依賴於另一個構建配置，而不是依賴於其輸出。
instead.setup.dependency.on.bc=替換為對構建配置 ''{0}'' (模塊 ''{1}'')的依賴
uml.create.relationship.label=<html>&laquo;創建&raquo;</html>
ios.simulator.on.mac.only.warning=iOS 模擬器僅在 Mac OS 上可用
ios.simulator.on.mac.only.button.text=iOS 模擬器(僅限 Mac)
ios.simulator.sdk.not.set=未設定 iOS 模擬器 SDK 的路徑
ios.simulator.sdk.not.found=找不到 iOS 模擬器 SDK: {0}
cant.execute.flexunit1.for.pure.as.bc=無法為純 ActionScript 構建配置執行 FlexUnit 1 測試。請使用 FlexUnit 4 或更高版本。
locales.dialog.label=Flex SDK ''{0}'' 支援的區域設定:
new.flex.component.command.name=創建 MXML 組件
create.flex.component.intention.name=創建 MXML 組件 ''{0}''
new.flex.component.action.description=新建 MXML 組件
new.flex.component.dialog.title=新 MXML 組件
new.flex.component.uml.action.text=MXML 組件
parent.component.label.text=父組件(&C):
parallel.compilation.hint.title=提示
parallel.compilation.hint=獨立 Flash 構建配置的並行編譯<br/>可以提高編譯性能。<br/><br/><a href="enable">啟用並行編譯</a>    <a href="open">打開編譯器設定 </a>
parallel.compilation.enabled=已啟用並行編譯
see.settings.compiler=要配置編譯器設定，請使用<a href="">設定->編譯器</a>頁面。
define.0=聲明條件編譯器定義 ''{0}''
failed.to.read.app.id=無法從以下檔案讀取應用程序 ID: \n{0}
add.as.library.title=添加為庫
bc.output.file.source.item={0}: 僅輸出檔案({1})
bc.output.file.and.wrapper.source.item={0}: 輸出檔案和 HTML 包裝器
bc.output.folder.source.item={0}: 整個輸出資料夾內容

# Annotator
javascript.validation.message.no.return.value.required.for.function=Object() { [native code] }=從構造函數中返回不需要返回值
configurable.FlexCompilerProjectConfigurable.display.name=ActionScript 和 Flex 編譯器
remove.annotation.from.class=從類中移除註解
this.will.remove.relationship.link.between.classes=這將移除類之間的關係
flash.builder.project.file=<b>Flash Builder</b> 項目檔案({0})

# used in FlashUmlVisibilityManager
javascript.uml.visibility.public=public
javascript.uml.visibility.protected=protected
javascript.uml.visibility.package_local=protected \\&\\& internal
javascript.uml.visibility.private=所有
javascript.uml.show.supers.header={0} 的超類
javascript.uml.show.implementations.header={0} 的實現

javascript.validation.message.static.method.in.interface=接口中不允許使用 static 方法
javascript.validation.message.static.method.with.override=static 函數不能包含重寫修飾符
invalid.identifier.value=標識符值無效
class.0.does.not.have.default.function=Object() { [native code] }=類 {0} 沒有預設構造函數
javascript.validation.empty.component.type=組件標記不應為空
javascript.validation.tag.must.be.last.child.of.root.tag=<{0}> 標記必須是根文檔標記的最後一個子級
javascript.validation.tag.must.be.first.child.of.root.tag=<{0}> 標記必須是根文檔標記的第一個子級
javascript.validation.tag.must.be.direct.child.of.fx.library.tag=<{0}> 標記必須是 <{1}> 標記的直接子級
javascript.validation.tag.must.have.exactly.one.child.tag=<{0}> 標記必須只有一個子標記
javascript.validation.tag.must.have.attribute.includein.or.excludefrom=<{0}> 標記必須有特性 ''includeIn'' 或 ''excludeFrom''
javascript.validation.only.this.tag.is.allowed.here=此處僅允許使用 <{0}> 標記
asdoc=ASDoc
invalid.package=無效軟件包: {0}
actionscript.template.context.type=ActionScript(&I)
to.indent.package.statement.children=縮進 package 語句子級(&I)
javascript.validation.message.file.should.be.under.source.root=對象位於源根目錄外的檔案中，某些功能不可用
javascript.validation.message.more.than.one.named.object.in.package=軟件包中的非唯一對象
javascript.validation.message.function=Object() { [native code] }.in.mxml.is.not.allowed=MXML 類不允許使用構造函數
javascript.validation.message.nested.packages.are.not.allowed=不允許嵌套軟件包
javascript.validation.message.package.shouldbe.first.statement=軟件包應為檔案中的第一條語句
javascript.validation.message.incorrect.package.name=軟件包名稱 ''{0}'' 與檔案路徑 ''{1}'' 不對應
javascript.fix.package.name=將軟件包名稱設定為 ''{0}''
javascript.validation.message.more.than.one.externally.visible.symbol=檔案中定義了多個外部可見符號
javascript.validation.message.vector.without.parameters=無類型的矢量
javascript.validation.message.vector.without.parameters2=無類型的矢量無法實例化
javascript.validation.message.access.modifier.allowed.only.for.package.members=軟件包成員僅允許使用 public/internal 修飾符
javascript.validation.message.access.modifier.allowed.only.for.class.members=僅類成員允許使用訪問修飾符
javascript.validation.message.namespace.allowed.only.for.class.members=僅類成員允許使用命名空間
javascript.validation.message.embed.annotation.used.with.var.of.wrong.type=嵌入註解應與類或字符串類型的變量一起使用
javascript.namespace.initializer.should.be.string.or.another.namespace.reference=命名空間初始值設定項應為字符串文字或其他命名空間引用
javascript.validation.message.class.should.be.in.file=應在檔案 ''{1}'' 中定義類 ''{0}''
javascript.validation.message.function.should.be.in.file=應在檔案 ''{1}'' 中定義函數 ''{0}''
javascript.validation.message.namespace.should.be.in.file=應在檔案 ''{1}'' 中定義命名空間 ''{0}''
javascript.validation.message.variable.should.be.in.file=應在檔案 ''{1}'' 中定義變量 ''{0}''
javascript.invalid.e4x.filter.query.receiver=e4x 篩選器查詢實參無效，應為 XML 或 XMLList 類型
javascript.callback.signature.mismatch=回調應只有一個事件類型的參數
javascript.callback.signature.mismatch.event.class=回調應只有一個{0}類型的參數
actionscript.binary.operand.type.mismatch=二元運算實參類型{0}與類型{1}不兼容
top.level=頂層
js.uml.presentable.name=ActionScript/Flex
actionscript.create.function=Object() { [native code] }.intention.name=創建構造函數 ''{0}''
new.actionscript.class.uml.action.text=ActionScript 類
new.actionscript.class.command.name=創建 ActionScript 類
new.actionscript.class.action.description=創建新的 ActionScript 類
cannot.resolve.package.0=無法解析軟件包 ''{0}''
cannot.resolve.class.0=無法解析類 ''{0}''