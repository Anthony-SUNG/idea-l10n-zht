#config
google.web.toolkit.title=Google Web Toolkit

#actions
dialog.title.google.web.toolkit=Google Web Toolkit
error.class.not.found.in.jar=在 ''{1}'' 中找不到類 ''{0}''
error.file.not.found.message=找不到文件 ''{0}''
error.invalid.gwt.installation.message=''{0}'' 不是有效的 GWT 安裝: {1}
error.message.path.to.gwt.sdk.must.not.contain.character=GWT SDK 路徑不得包含 '!' 字符
fix.download.gwt=下載 GWT…

new.service.dlg.prompt=輸入新 GWT 遠程服務的名稱
new.service.dlg.title=新建 GWT 遠程服務
new.service.progress.text=創建 GWT 遠程服務 ''{0}''

new.serial.dlg.prompt=輸入新的 GWT 可序列化類的名稱
new.serial.dlg.title=新建 GWT 可序列化類
new.serial.progress.text=正在創建 GWT 可序列化類 ''{0}''

new.module.dlg.prompt=輸入新 GWT 模塊的名稱(&E)
new.module.dlg.title=新建 GWT 模塊
new.module.progress.text=正在創建 GWT 模塊 ''{0}''

new.entry.point.dlg.prompt=輸入新 GWT 入口點的名稱
new.entry.point.dlg.title=新建 GWT 入口點
new.entry.point.progress.text=正在創建 GWT EntryPoint ''{0}''


problem.description.unknown.css.class=未知 CSS 類 ''{0}''
quickfix.name.create.css.class.0=創建 CSS 類 ''{0}''
quickfix.family.name.create.css.class=創建 CSS 類
quickfix.name.create.local.css.class.0=創建局部 CSS 類 ''{0}''
quickfix.family.name.create.local.css.class=創建局部 CSS 類
inspection.unresolved.references.to.css.classes.display.name=對 CSS 類的未解析引用
group.gwt.inspections.name=Google Web Toolkit
css.usages.variable=變量

problem.description.methods.of.async.remote.service.0.isn.t.synchronized.with.1=異步遠程服務 ''{0}'' 的方法與 ''{1}'' 不一致
problem.description.remote.service.0.does.not.have.corresponding.async.variant=遠程服務 ''{0}'' 沒有相應的異步變體
problem.description.async.remote.service.0.does.not.define.corresponding.method=異步遠程服務 ''{0}'' 未定義相應的方法
inspection.name.inconsistent.gwt.remote.service=不一致的遠程服務
quick.fix.name.synchronize.all.methods.of.0.with.1=將 ''{0}'' 的所有方法與 ''{1}'' 同步
quickfix.name.create.async.method.for.sync.0=為方法 ''{0}'' 創建異步變體
quickfix.family.name.create.async.variant=創建異步變體
problem.description.async.method.does.not.have.sync.variant=方法 ''{0}'' 沒有相應的同步變體
quickfix.name.create.sync.method.for.async.0=為方法 ''{0}'' 創建同步變體
quickfix.family.name.create.sync.variant=創建同步變體
problem.description.the.asynchronous.version.of.method.0.must.have.a.return.type.void=方法 ''{0}'' 的異步版本必須具有返回類型 ''void''、\n''com.google.gwt.http.client.Request'' 或 ''com.google.gwt.http.client.RequestBuilder''
quickfix.name.make.0.return.void=使 ''{0}'' 返回 ''void''
quickfix.family.name.make.method.return.void=使方法返回 'void'

problem.description.type.is.not.serializable=類型 ''{0}'' 不可序列化
problem.description.type.of.collection.elements.is.not.specified=未指定 ''{0}'' 元素的類型
problem.description.gwt.serializable.type.0.should.implements.marker.interface.1=類型 ''{0}'' 未實現標記接口 {1}
text.0.or.1=''{0}'' 或 ''{1}''
problem.description.0.is.not.a.checked.exception=''{0}'' 不是檢查過的例外
quickfix.name.create.interface.0=創建接口 ''{0}''
quickfix.family.name.create.interface=創建接口
inspection.name.non.serializable.service.method.parameters=不可序列化的服務方法形參類型或返回類型
problem.description.generics.isnt.supported.in.gwt.before.1.5.version=1.5 版之前的 GWT 不支持泛型
checkbox.text.report.interfaces=報告接口

label.choose.module.text=模塊(&M):
run.gwt.configuration.display.name=GWT 配置
run.gwt.configuration.description=GWT 配置
default.gwt.run.configuration.name=未命名
error.text.gwt.facet.not.configured.in.module.0=未為模塊 ''{0}'' 配置 GWT Facet
error.text.gwt.sdk.is.not.specified.correctly=在模塊 ''{0}'' 的 GWT Facet 設置中未正確指定 GWT SDK 路徑
error.text.no.gwt.modules.in.module.0=在 ''{0}'' 中找不到 GWT 模塊
question.text.gwt.facet.is.not.configured.for.module.0.do.you.want.to.create.it=沒有為模塊 ''{0}'' 配置 GWT Facet。要創建嗎?

inspection.name.unresolved.references.to.html.tags=對 html 標記的未解析引用
problem.description.html.tag.with.id.0.is.not.found=找不到 ID 為 ''{0}'' 的 HTML 標記
quick.fix.name.rename.reference=重命名引用

inspection.name.classes.not.from.jre.emulation.library.in.client.code=使用 JRE Emulation Library 中不存在的類和方法
problem.description.class.0.is.not.presented.in.jre.emulation.library=JRE 仿真庫中不存在類 ''{0}''，因此不能在 ''{1}'' GWT 模塊的客戶端代碼中使用
problem.description.method.0.is.not.presented.in.jre.emulation.library=JRE 仿真庫中不存在方法 ''{0}''，因此不能在 ''{1}'' GWT 模塊的客戶端代碼中使用
problem.description.class.0.is.defined.in.module.1.which.is.not.inherited.in.module.2=類 ''{0}'' 在模塊 ''{1}'' 中定義，而該模塊在模塊 ''{2}'' 中未被繼承
quickfix.name.inherit.module.0.from.1=從 ''{1}'' 集成模塊 ''{0}''
quickfix.family.name.inherit.module=繼承模塊

inspection.name.client.class.from.non.inherited.module.usage=使用未繼承的 GWT 模塊中的客戶端類

inspection.name.gwt.remote.service.is.not.registered.in.web.xml=GWT 遠程服務未在 web.xml 中註冊
problem.description.remote.service.is.not.registered.as.a.servlet.in.web.xml=遠程服務 ''{0}'' 未在 web.xml 中註冊為 servlet。
quickfix.name.register.remote.service.0.in.web.xml=在 ''web.xml'' 中註冊遠程服務 ''{0}''
quickfix.family.name.register.remote.service.in.web.xml=在 'web.xml' 中註冊遠程服務
problem.description.correct.servlet.mapping.is.not.specified.for.remote.service.0=沒有為遠程服務 ''{0}'' 指定正確的 servlet 映射
quickfix.name.add.servlet.mapping.for.remote.service.0=為遠程服務 ''{0}'' 添加 servlet 映射
quickfix.family.name.add.servlet.mapping.for.remote.service=為遠程服務添加 servlet 映射
problem.description.incorrect.servlet.mapping.for.remote.service.0=遠程服務 ''{0}'' 的 URL 格式不正確
quickfix.name.set.correct.servlet.mapping.for.remote.service.0=為遠程服務 ''{0}'' 設置正確的 URL 格式
quickfix.family.name.set.servlet.mapping.for.remote.service=為遠程服務設置正確的 URL 格式
quickfix.name.create.web.facet.and.register.remote.service.0.in.web.xml=創建 Web Facet 並在 ''web.xml'' 中註冊遠程服務 ''{0}''
quickfix.family.name.create.web.facet.and.register.remote.service.in.web.xml=創建 Web Facet 並在 'web.xml' 中註冊遠程服務
quickfix.name.connect.gwt.facet.to.0.facet.and.register.remote.service.1.in.web.xml=將 GWT Facet 連接到 ''{0}'' Facet，並在 ''web.xml'' 中註冊遠程服務 ''{1}''
quickfix.family.name.connect.gwt.facet.and.register.remote.service.in.web.xml=連接 GWT Facet 並在 'web.xml' 中註冊遠程服務

file.template.group.title.gwt=Google Web Toolkit

action.group.gwt.title=Google Web Toolkit
action.group.gwt.description=Google Web Toolkit

label.text.path.to.gwt.installation=GWT 安裝目錄路徑(&P):
gwt.installation.chooser.title=GWT 安裝目錄路徑
gwt.installation.chooser.description=請指定 GWT 安裝目錄的路徑
error.message.gwt.user.jar.library.not.found.in.dependencies.of.module=在模塊的依賴項中找不到 gwt-user.jar 庫
error.message.gwt.user.jar.in.library.0.does.not.correspond.to.selected.gwt.installation=庫 ''{0}'' 中的 gwt-user.jar 與所選 GWT 安裝不相符
label.select.script.output.style.text=JavaScript 輸出樣式(&O):
label.select.web.facet.text=目標 Web Facet(&W):
label.text.gwt.compiler.heap.size=編譯器最大堆大小 (Mb)(&H):
table.column.name.gwt.module=GWT 模塊
table.column.name.output.relative.path=輸出相對路徑
label.text.additional.compiler.parameters=附加編譯器 VM 選項(&A):
label.text.gwt.compiler.parameters=編譯器參數(&C):
label.html.to.open.text=起始頁面(&P):
dialog.caption.vm.parameters=VM 選項
label.text.vm.parameters=虛擬機選項(&V):
label.text.gwt.dev.mode.parameters=開發模式參數(&D):
dialog.caption.gwt.dev.mode.parameters=GWT 開發模式參數
checkbox.text.use.custom.web.xml=使用自定義 'web.xml' 描述符的內容(&W)
choose.text.select.gwt.module=選擇 GWT 模塊:
dialog.title.choose.gwt.module=GWT 模塊
label.text.gwt.module.to.load=要加載的 GWT 模塊(&G):
text.gwt.modules.to.load.all=所有
text.gwt.modules.to.load.none=無

i18n.interface.method.gutter.tooltip=<html><body>方法在 {0} {0, choice, 1#個文件|2#個文件}中有關聯的屬性
i18n.goto.property.popup.title=<html><body>選擇 <b>{0}</b> 的本地化(找到 {1} 個文件)</body></html>
i18n.class.gutter.tooltip.text=類有 {0} 個關聯的屬性 {0, choice, 1#文件|2#文件}

inspection.name.inconsistent.gwt.localizable.interface=不一致的本地化接口
problem.description.property.0.does.not.have.corresponding.method.in.1=屬性 ''{0}'' 在 ''{1}'' 中沒有對應的方法
quickfix.name.create.method.for.property.0.in.1=為 ''{1}'' 中的屬性 ''{0}'' 創建方法
quickfix.name.synchronize.all.methods.in.0=將所有缺少的方法添加到 ''{0}''
quickfix.family.name.create.missing.methods=創建缺少的方法
problem.description.method.0.does.not.have.corresponding.property=方法 ''{0}'' 沒有對應的屬性
quickfix.name.create.property.0=創建屬性 ''{0}''
quickfix.family.name.create.property=創建屬性
quickfix.popup.title.choose.properties.file=選擇屬性文件

quickfix.name.change.0.type.to.1=將 ''{0}'' 類型更改為 ''{1}''
quickfix.family.name.change.field.type=更改字段類型

quickfix.name.create.def.declaration.for.0=為 ''{0}'' 創建 ''@def'' 聲明
quickfix.family.name.create.def.declaration=創建 '@def' 聲明

quickfix.name.register.0.subpackage.as.1.path=將 ''{0}'' 子軟件包註冊為 {1} 路徑
quickfix.family.name.register.subpackage=註冊子軟件包

quickfix.name.create.0.method=創建 ''{0}'' 方法

quickfix.name.replace.0.with.1=將 ''{0}'' 替換為 ''{1}''
quickfix.family.name.replace.listener.with.handler=將偵聽器替換為處理程序

inspection.name.incorrect.serializable.class=不正確的可序列化類
problem.description.field.0.is.not.serializable=類型 ''{0}'' 不可序列化
problem.description.serializable.class.should.provide.public.no.args.function Object() { [native code] }=可序列化的類應提供 public 無參數構造函數
inspection.name.method.with.parameters.in.interface.extending.constants=接口擴展 Constants 中帶有參數的方法
problem.description.methods.with.parameters.are.not.allowed.in.an.interface.extending.constants=接口擴展 Constants 中不允許使用帶有參數的方法
problem.description.properties.with.parameters.are.not.allowed.if.the.associated.interface.extends.constants=如果關聯接口擴展 Constants，則不允許使用帶有參數的屬性
quickfix.name.inherit.0.from.messages.instead.of.constants=從消息而不是 Constants 繼承 ''{0}''
quickfix.family.name.inherit.from.messages.instead.of.constants=將 Constants 替換為 Messages

inspection.name.unresolved.references.in.jsni.methods=JSNI 方法中未解析的引用
inspection.name.unresolved.references.in.ui.xml.files=ui.xml 文件中未解析的引用
problem.description.cannot.resolve.0=無法解析 ''{0}''
problem.description.cannot.resolve.symbol.0.in.1=無法解析 ''{1}'' 中的符號 ''{0}''
problem.description.ambiguous.wildcard.match=不明確的通配符匹配: ''{2}'' 中的 ''{0}'' 和 ''{1}'' 都與 ''{3}'' 匹配
problem.description.class.is.not.widget=類 ''{0}'' 未實現 ''IsWidget'' 接口

problem.description.inconsistent.element.type=UiBinder 接口參數與 ''{0}'' 標記不一致。應為 ''{1}'' 或其超類
problem.description.ui.xml.not.found=UiBinder 接口沒有對應的 ui.xml 文件
problem.description.ui.xml.root.not.found=無法在對應的 ui.xml 文件中檢測到根標記
problem.description.ui.xml.root.ambiguity=在對應的 ui.xml 文件中檢測到過多根標記

inspection.name.incorrect.java.methods.calls.in.js=從 JavaScript 代碼中不正確調用 Java 方法
problem.description.cannot.call.instance.method.without.object.instance=沒有對象實例，無法調用實例方法 ''{0}''
problem.description.incorrect.number.of.arguments.for.method=''{0}'' 方法的參數數量不正確: 應為 {1} 個，但實際為 {2} 個

inspection.name.overlay.type.restrictions.violated=違反覆蓋類型限制
problem.description.function Object() { [native code] }.in.overlay.type.cannot.have.parameters=覆蓋類型中的構造函數不能有參數
problem.description.function Object() { [native code] }.in.overlay.type.must.be.protected=覆蓋類型中的構造函數必須為 protected
problem.description.function Object() { [native code] }.in.overlay.type.must.have.empty.body=覆蓋類型中的構造函數的主體必須為空
problem.description.overlay.type.must.have.protected.empty.no.arg.function Object() { [native code] }=覆蓋類型必須具有不帶參數的 protected 空構造函數
problem.description.overlay.type.cannot.have.instance.fields=覆蓋類型不能包含實例字段
problem.description.inner.classes.in.overlay.type.must.be.static=覆蓋類型中的內部類必須為 static
problem.description.instance.methods.in.overlay.type.must.be.final=覆蓋類型中的實例方法必須為 final

inspection.name.obsolete.gwt.type.args.tag.in.javadoc.comments=JavaDoc 注釋中棄用的 '@gwt.typeArgs' 標記
problem.description.gwt.type.args.tag.is.obsolete.in.gwt.1.5=GWT 1.5 中已棄用 '@gwt.typeArgs' 標記
quickfix.name.generify.types.in.method.0.instead.of.using.gwt.type.args.tags=在方法 ''{0}'' 中使用形參化類型，不使用 ''@gwt.typeArgs'' 標記
quickfix.family.name.generify.types.in.method=使用形參化類型
gwt.searching.for.implementations=正在搜索實現…

quickfix.name.set.provided.to.true=將 'provided' 特性設置為 'true'

inspection.name.raw.use.of.async.callback.in.asynchronous.service.interfaces=在異步服務接口中原始使用 AsyncCallback
problem.description.raw.use.of.async.callback.interface=在方法 ''{0}'' 中原始使用 AsyncCallback 接口
quickfix.name.replace.async.callback.by.async.callback.0=將 ''AsyncCallback'' 替換為 ''AsyncCallback<{0}>''
quickfix.family.name.replace.async.callback.by.generic.async.callback=泛化 'AsyncCallback'

inspection.name.redundant.set.service.entry.point.methods.calls=冗餘的 'setServiceEntryPoint()' 方法調用
error.message.set.service.entry.point.method.call.can.be.replaced.by.remote.service.relative.path.annotation='setServiceEntryPoint()' 方法調用可以替換為 '@RemoteServiceRelativePath' 注解
error.message.set.service.entry.point.method.call.is.redundant='setServiceEntryPoint()' 方法調用冗餘，因為入口點由 '@RemoteServiceRelativePath' 注解指定

inspection.name.incorrect.argument.of.gwt.create.method=不正確的 GWT.create() 方法參數
problem.description.only.class.literals.may.be.used.as.arguments.to.gwt.create=只能將類文字用作 GWT.create() 的參數

error.message.this.action.is.allowed.only.for.client.side.packages.of.a.gwt.module=此操作僅適用於 GWT 模塊的客戶端軟件包

border.title.gwt.compilation=GWT 編譯
framework.title.google.web.toolkit=Google Web 工具包(&G)
inspection.name.deprecated.gwt.key.tag.in.javadoc.comments=JavaDoc 注釋中棄用的 '@gwt.key' 標記
problem.description.gwt.key.tag.is.deprecated.in.gwt.1.5=GWT 1.5 中已棄用 '@gwt.key' 標記
quickfix.name.replace.gwt.key.tag.with.key.annotation.in.method.0=將 ''@gwt.key'' 標記替換為方法 ''{0}'' 中的 @Key 注解
quickfix.family.name.replace.gwt.key.tag.with.key.annotation=將 '@gwt.key' 標記替換為 @Key 注解
dialog.promt.enter.name.for.gwt.test.case=輸入 GWT 測試用例的名稱:
dialog.title.new.gwt.test.case=新建 GWT 測試用例
action.progress.creating.gwt.test.case.0=創建 GWT 測試用例 ''{0}''

quickfix.name.replace.set.service.entry.point.call.by.annotation=通過注解替換 'setServiceEntryPoint()' 調用
quickfix.name.remove.redundant.set.service.entry.point.call=移除冗餘的 'setServiceEntryPoint()' 調用
error.message.0.is.not.under.public.roots.of.gwt.modules.nor.under.web.roots=''{0}'' 不在 GWT 模塊的 ''public'' 根目錄下，也不在 Web 根目錄下，因此無法在托管模式瀏覽器中打開。
error.message.uibinder.is.supported.in.gwt.2.0.or.later=GWT 2.0 或更高版本支持 UiBinder
label.text.enter.name.for.new.gwt.uibinder.class.and.ui.xml.file=輸入新的 GWT UiBinder 類和 ui.xml 文件的名稱(&E):
dialog.title.create.new.gwt.uibinder.class.and.ui.xml.file=創建新的 GWT UiBinder 類和 ui.xml 文件
action.name.create.gwt.uibinder.0.and.1.ui.xml.file=創建 GWT UiBinder ''{0}'' 和 ''{1}.ui.xml'' 文件
error.message.uirenderer.is.supported.in.gwt.2.5.or.later=GWT 2.5 或更高版本支持 UiRenderer
label.text.enter.name.for.new.gwt.uirenderer.class.and.ui.xml.file=輸入新的 GWT UiRenderer 類和 ui.xml 文件的名稱(&E):
dialog.title.create.new.gwt.uirenderer.class.and.ui.xml.file=創建新的 GWT UiRenderer 類和 ui.xml 文件
action.name.create.gwt.uirenderer.0.and.1.ui.xml.file=創建 GWT UiRenderer ''{0}'' 和 ''{1}.ui.xml'' 文件
label.text.select.root.element.type=指定根元素的類型(&S):

dialog.title.create.gwt.event.with.handler=創建新的 GWT 事件和處理程序類
action.name.create.gwt.event.with.handler=創建 GWT 事件 ''{0}'' 及其處理程序類
error.message.gwt.event.not.supported=GWT 1.6 或更高版本支持 GwtEvent

popup.title.resource.method.goto=<html><body>為 <b>{0}</b> 選擇文件(找到 {1} 個文件)</body></html>
tooltip.text.resource.method.gutter=方法{0, choice, 1#有|2#有} {0} 個關聯的資源{0, choice, 1#文件|2#文件}

popup.title.css.class.method.goto=<html><body>為 <b>{0}</b> 方法選擇文件(找到 {1} 個文件)</body></html>
tooltip.text.css.class.method.gutter=方法{0, choice, 1#有|2#有}  個關聯的 css {0, choice, 1#類|2#類}
tooltip.text.css.declaration.method.gutter=方法{0, choice, 1#有|2#有}  個關聯的 css {0, choice, 1#元素|2#元素}

popup.title.css.file.goto=<html><body>為 <b>{0}</b> 選擇文件(找到 {1} 個文件)</body></html>
tooltip.text.css.file.gutter=類{0, choice, 1#有|2#有} {0} 個關聯的 css {0, choice, 1#文件|2#文件}
label.text.event.class.name=事件類名(&E):
label.text.handler.class.name=處理程序類名(&H):
label.text.event.handler.method.name=處理方法名稱(&M):

popup.title.ui.xml.file.goto=<html><body>為 <b>{0}</b> 選擇 ui.xml 文件(找到 {1} 個文件)</body></html>
tooltip.text.ui.xml.file.gutter=類{0, choice, 1#有|2#有} {0} 個關聯的 ui.xml {0, choice, 1#文件|2#文件}
popup.title.ui.tag.file.goto=<html><body>為 <b>{0}</b> 字段選擇 ui.xml 文件(找到 {1} 個文件)</body></html>
tooltip.text.ui.tag.file.gutter=字段在 {0} 個 ui.xml {0, choice, 1#文件|2#文件}中{0, choice, 1#有|2#有} 個關聯的{0, choice, 1#標籤|2#標籤}


gwt.intention.category=Google Web Toolkit

exportable.GwtSdkManager.presentable.name=GWT SDK

checkbox.text.separate.methods=為每個字段生成分隔方法(&S)

gwt.insufficient.language.level={0} (由 GWT Facet 配置)

gwt.notification.display.id=GWT
implementation.provided=由 GWT 提供實現

action.GWT.GenerateUiHandlerMethod.text=@UiHandler 方法…
action.GWT.NewSerialClass.text=GWT 可序列化類
action.GWT.NewSerialClass.description=創建實現 IsSerializable 的新 GWT 類
action.GWT.NewRemoteService.text=GWT 遠程服務
action.GWT.NewRemoteService.description=創建擴展 RemoteService、對應的異步版本和實現類的新 GWT 接口
action.GWT.GenerateCompileReport.text=生成 GWT 編譯報告…
action.GWT.GenerateCompileReport.description=運行 GWT 編譯器以生成編譯報告，並在瀏覽器中打開結果
action.GWT.NewUiBinder.text=GWT UiBinder 和 ui.xml 文件
action.GWT.NewUiRenderer.text=GWT UiRenderer 和 ui.xml 文件
action.GWT.NewEventWithHandler.text=GWT 事件和處理程序類
action.GWT.NewEntryPoint.text=GWT 入口點
action.GWT.NewEntryPoint.description=創建擴展 EntryPoint 的新 GWT 類
action.GWT.NewModule.text=GWT 模塊
action.GWT.NewModule.description=創建新的 GWT 模塊框架
action.GWT.NewTestCase.text=GWT 測試用例
group.GWT.text=Google Web Toolkit

message.text.gwt.module.chooser.isn.t.available.while.updating.indices=在 {0} 更新索引期間，GWT 模塊選擇器不可用
dialog.title.choose.gwt.modules.to.load=選擇要加載的 GWT 模塊
label.none.facet.selected=<none>
dialog.title.no.gwt.modules.found.in.the.project=在項目中找不到 GWT 模塊
intention.text.create.uihandler.for.tag=為標記創建 '@UiHandler'
label.text.0.is.used=使用了 {0}
content.display.name.server=服務器
content.display.name.modules=模塊
content.display.name.dev.mode=開發模式
psi.viewer.name.gwt.ui.xml.file=GWT ui.xml 文件
popup.step.title.select.artifact=選擇工件
validation.result.gwt.compiler.output.is.not.included.in.an.artifact=GWT 編譯器輸出未包含在工件中
validation.result.gwt.servlet.jar.is.not.included.in.0.artifact=gwt-servlet.jar 不包含在工件 ''{0}'' 中
task.title.updating.gwt.dev.mode.resources=正在更新 GWT 開發模式資源
progress.indicator.copying.files=正在複製文件…
progress.indicator.deleting.obsolete.files=正在刪除過時的文件…
progress.indicator.processing.files=正在處理文件…
task.title.preparing.war.directory.for.gwt.dev.mode=為 GWT 開發模式準備 WAR 目錄
problem.descriptor.description.template.expected.0.but.1.found=應為 ''{0}''，但實際為 ''{1}''
problem.descriptor.description.template.uifield.0.should.not.be.private=@UiField ''{0}'' 不應為 ''private''
problem.descriptor.description.template.0.is.not.annotated.with.uifield=''{0}'' 未使用 @UiField 進行注解
problem.descriptor.description.template.0.field.is.not.bound.to.tag.in.1.file=''{0}'' 字段未綁定到 ''{1}'' 文件中的標記
problem.descriptor.description.template.duplicate.declaration.bound.to.0.field=綁定到 ''{0}'' 字段的聲明重複
problem.descriptor.description.template.uibinder.class.not.found.for.0=找不到 ''{0}'' 的 UiBinder 類
problem.descriptor.description.template.cannot.resolve.0.field=無法解析 ''{0}'' 字段
problem.descriptor.description.template.handler.0.cannot.be.registered.methods.1.and.2.are.ambiguous=無法註冊處理程序 ''{0}'': 方法 ''{1}'' 和 ''{2}'' 不明確
problem.descriptor.description.template.field.0.does.not.have.addhandler.method.for.1=字段 ''{0}'' 沒有用於 ''{1}'' 的 ''addHandler'' 方法
problem.descriptor.description.template.handler.method.0.signature.does.not.match.1.signature=處理程序方法 ''{0}'' 簽名與 ''{1}'' 簽名不匹配
problem.descriptor.description.template.handler.class.0.1=處理程序類 ''{0}'' {1, choice, 0#沒有方法|2#定義了一個以上的方法}
problem.descriptor.description.template.cannot.get.eventhandler.type.for.0=無法獲取 ''{0}'' 的 EventHandler 類型
problem.descriptor.description.template.cannot.get.eventhandler.type.for.02=無法獲取 ''{0}'' 的 EventHandler 類型
problem.descriptor.description.template.parameter.0.is.not.an.event.subclass.of.gwtevent=形參 ''{0}'' 不是事件(GwtEvent 的子類)
problem.descriptor.description.template.uihandler.0.must.have.a.single.event.parameter.defined=@UiHandler ''{0}'' 必須只定義一個事件參數
problem.descriptor.description.template.uihandler.0.must.have.at.least.one.parameter.defined=@UiHandler ''{0}'' 必須至少定義一個參數
problem.descriptor.description.template.uihandler.0.should.not.be.private=''@UiHandler ''{0}'' 不應為 ''private''
intention.text.create.uifield.for.tag=為標記創建 '@UiField'
dialog.message.incorrect.number.of.type.parameters.in.0.class={0} 類中的類型形參數量不正確。
dialog.message.0.class.not.found=找不到 {0} 類。
action.ViewReportAction.text=查看報告
label.text.compile.report.was.generated.0.ago=編譯報告於 {0}前生成
button.text.generate=生成
dialog.title.generate.gwt.compile.report=生成 GWT 編譯報告
label.text.download.gwt=下載 GWT
label.text.gwt.sdk.path.not.specified=未指定 GWT SDK 路徑。
task.title.looking.for.changed.classes=正在查找更改的類
running.app.updater.description.update.0=更新 ''{0}''
dialog.message.root.element.type.is.not.specified=未指定根元素類型
dialog.message.cannot.create.sample.gwt.application.0=無法創建示例 GWT 應用程序: {0}
library.presentation.description=GWT SDK 庫
gwt.compiler.deploy.output.element.type.name=GWT 編譯器部署輸出
gwt.compiler.output.element.type.dialog.title=選擇模塊
gwt.compiler.output.element.type.dialog.description=選擇包含 GWT Facet 的模塊
gwt.compiler.output.element.type.name=GWT 編譯器輸出
popup.title.choose.css.file=選擇 CSS 文件
command.create.sample.gwt.project.files=創建示例 GWT 項目文件
notification.content.gwt.file.mapping.is.not.possible.during.index.update=在索引更新期間無法進行 GWT 文件映射
artifact.node.gwt.compiler.output=GWT 編譯器輸出
artifact.node.gwt.deploy.output=GWT 部署輸出
quickfix.text.include.in.artifact=包含在工件中
quickfix.text.include.into.0=包含到 ''{0}'' 中
quickfix.text.create.artifact=創建工件
tooltip.gwt.modules.without.entry.points.cannot.be.compiled=無法編譯沒有入口點的 GWT 模塊
dialog.title.select.event.type=選擇事件類型
dialog.title.choose.fields.to.generate.handler.for=選擇要為其生成處理程序的字段
label.gwt.0.sdk.from.maven.repository=來自 Maven 倉庫的 GWT {0} SDK
notification.content.unable.to.configure.gwt.unit.tests.during.index.update=在索引更新期間無法配置 GWT 單元測試
dialog.title.select.type.of.root.element=選擇根元素的類型
inspection.message.0.is.deprecated.in.gwt.1.6=''{0}'' 在 GWT 1.6 中被棄用
label.text.gwt.0.sdk.from.gradle.repository=來自 Gradle 的 GWT {0} SDK
status.bar.text.gwt.dev.mode.resources.for.0.updated=''{0}'' 的 GWT 開發模式資源{2, choice, 0#已于 {1} 更新|1#已處於最新狀態}
tab.title.0.gwt.output=''{0}'' GWT 輸出
inspection.message.assignment.to.uifield.annotated.field.will.be.ignored=對 @UiField 注解字段的賦值將被忽略，因為它由 UiBinder 初始化
quickfix.name.create.missing.methods=創建缺少的方法
inspection.message.0.css.classes.do.not.have.corresponding.methods={0} CSS 類沒有對應的方法
quickfix.name.create.method.for.0=為 ''{0}'' 創建方法
inspection.message.css.class.0.does.not.have.corresponding.method=CSS 類 ''{0}'' 沒有對應的方法
quickfix.name.0.css.class.or.def.element.not.found=找不到 ''{0}'' css 類或 ''@def'' 元素
item.text.0.and.more.modules={0} 和{2, choice, 0#其他 1 個模塊|1#其他 {1} 個模塊}
error.message.0.parameter.used.without.corresponding.war=使用的 {0} 參數時未使用對應的 -war
error.message.cannot.create.socket.0=無法創建套接字: {0}
error.message.unknown.gwt.dev.mode.server.0=未知的 GWT 開發模式服務器: {0}
inspection.message.0.subpackage.is.not.registered.as.1.path.in.2=''{0}'' 子軟件包未在 ''{2}'' 中作為 {1} 路徑進行註冊
console.message.dev.mode.initialized.startup.urls=開發模式已初始化{0, choice, 0#|1#。啟動 URL:|2#。啟動 URL:}
parsing.error.rule.expected=應為規則
checkbox.create.html.and.css.files.in.directory=在目錄中創建 HTML 和 CSS 文件(&C)
checkbox.show.compiler.output=顯示編譯器輸出(&S)
label.gwt.modules.are.not.available.while.index.update.is.in.progress=GWT 模塊在索引更新期間不可用
label.label=標籤
checkbox.create.sample.application=創建示例應用程序(&C)
label.gwt.sdk=GWT SDK:
label.gwt.module=GWT 模塊(&G):
checkbox.update.resources.on.frame.deactivation=切換出IDE時更新資源(&U)
checkbox.open.in.browser=在瀏覽器中打開(&B):
label.server=服務器(&R):
checkbox.use.super.dev.mode=使用超級開發模式
checkbox.with.javascript.debugger=使用 JavaScript 調試器
label.module=模塊:

inspection.GwtDeprecatedEventListeners.name=使用棄用的事件偵聽器
inspection.GwtUiFieldErrors.name=包含 '@UIField' 注解的不一致字段
inspection.GwtUiHandlerErrors.name=包含 '@UiHandler' 注解的不一致方法
inspection.GwtUiBinderErrors.name='UiBinder' 接口的不一致實現
inspection.GwtDefaultPackageNotRegistered.name='client' 軟件包或 'public' 目錄未在 gwt.xml 文件中註冊
inspection.GwtUiFieldAssignment.name=賦值給包含 '@UiField' 注解的字段
inspection.GwtCssResourceErrors.name=擴展 'CssResource' 的不一致接口
action.GWT.NewUiBinder.description=創建擴展 UiBinder 的類和相應的 ui.xml 文件
action.GWT.NewUiRenderer.description=創建擴展 UiRenderer 的類和相應的 ui.xml 文件
action.GWT.NewEventWithHandler.description=創建一個擴展 GwtEvent 的類和相應的擴展 EventHandler 的類
action.GWT.NewTestCase.description=創建一個擴展 GWTTestCase 的新類