method=方法
function=函數
block=塊
lambda=Lambda
callable.type.title=可調用類型
annotator.type.literals.are.not.supported=編譯器不支持 {0} 文字
extract.category.dialog=提取類別
extract.category.unable.create.file=無法創建文件
extract.unavailable.for.protocols=此操作不適用於協議
extract.method.selected.block.hint=所選塊應代表一組語句或表達式
extract.method.cannot.determine.hint=無法確定所選表達式的類型
extract.class.use.protocol.instead=改用“提取超級協議”
extract.class.element.not.located.hint=所選元素是一個不在項目內部的類上的類別
extract.subclass.dialog.title=提取子類
extract.symbol.already.exist={0} 已存在
create.file.title=文件
create.file.description=創建新文件

create.field.name.category=類別名稱(&N):

create.field.language=語言(&L):
create.field.class=類(&C):
create.class.title=Objective-C 類
create.class.dialog.title=新建 Objective-C 類
create.class.objc=Objective-C (.m)
create.class.objcpp=Objective-C++ (.mm)
create.class.description=創建新的 Objective-C 類和頭文件
create.protocol.title=Objective-C 協議
create.protocol.description=創建新的 Objective-C 協議
create.protocol.dialog.title=新建 Objective-C 協議
create.category.title=Objective-C 類別
create.category.description=創建新的 Objective-C 類別
create.category.dialog.title=新建 Objective-C 類別
create.checkbox.category.interface=創建接口文件(&I)
create.category.no.class.dialog=找不到類 ''{0}''。\n要創建類別嗎?
create.category.no.class.dialog.title=類無效
create.implementation.title=實現
create.implementation.description=創建新的實現
create.interface.title=接口
create.interface.description=創建新的接口
codeassists.surroundwith.expression=環繞方式
copy.files.handler.fail=無法將文件複製到 ''{0}''
code.style.remember.choice=記住選擇
refactoring.categoryElement.not.in.project=所選元素位於不在項目內部的類上的類別中
refactoring.category.not.in.project=所選元素是一個不在項目內部的類上的類別
navigation.import.hierarchy.including.title=包含 {0} 的文件
navigation.import.hierarchy.including.action=包含層次結構
navigation.import.hierarchy.including.action.description=切換到包含層次結構
navigation.import.hierarchy.included.title={0} 包含的文件
navigation.import.hierarchy.included.action=已包含的層次結構
navigation.import.hierarchy.included.action.description=切換到已包含的層次結構
navigation.import.hierarchy.next.occurence=轉到下一個文件
navigation.import.hierarchy.previous.occurence=轉到上一個文件
navigation.goto.please.wait=請稍候…
navigation.goto.resolving.target=解析目標…
naming.convention.title=命名慣例
naming.convention.header.guard.style.help=您可以使用預定義變量，例如:<br><b>${PROJECT_NAME}</b>、 <b>${PROJECT_REL_PATH}</b>、 <b>${FILE_NAME}</b>、 <b>${EXT}</b> 和 <b>${UUID}</b>。<br>所有來自<i>編輯器/文件和代碼模板</i> (<i>“文件”選項卡</i>)<br>的預定義變量也可用(例如 <b>${USER}</b>、<b>${DATE}</b> 等)
naming.convention.entity.kind=實體種類
naming.convention.visibility=可見性
naming.convention.specifier=說明符
naming.convention.entity.any=任意
naming.convention.entity.namespace=命名空間
naming.convention.entity.macro=宏
naming.convention.entity.class=類
naming.convention.entity.struct=結構
naming.convention.entity.enumeration=枚舉
naming.convention.entity.union=聯合
naming.convention.entity.typedef=Typedef
naming.convention.entity.global.function=全局函數
naming.convention.entity.global.variable=全局變量
naming.convention.entity.class.member.function=類成員函數
naming.convention.entity.struct.member.function=結構成員函數
naming.convention.entity.class.member.field=類成員字段
naming.convention.entity.struct.member.field=結構成員字段
naming.convention.entity.enumerator=枚舉器
naming.convention.entity.parameter=形參
naming.convention.entity.local.variable=局部變量
naming.convention.prefix=前綴
naming.convention.suffix=後綴
refactoring.convertIvarUsagesToProperties=將 ivar 用法轉換為屬性(&C)
refactoring.ambiguous=不明確的函數無法被重構
title.function.return.type.group=函數返回類型之後
title.function.top.return.type=在全局和命名空間範圍中
title.function.nontop.return.type=在類範圍中
title.function.parameters.group=函數聲明形參
title.function.call.arguments.group=函數調用實參
title.template.decl.class.group=模板類聲明
title.template.decl.func.group=模板函數聲明
title.template.parameters.group=模板聲明形參
title.template.call.arguments.group=模板實例化實參
title.ctor.init.list.group=構造函數初始化列表
title.superclass.list.group=基類列表
title.shift.operators.group='<<', '>>' 運算符
title.capture.list.group=Lambda 捕獲列表
wrapping.new.line.after.lt=在 '<' 后換行
wrapping.gt.on.new.line=將 '>' 置於新行
wrapping.align.multiline.parentheses=對齊多行括號
wrapping.align.multiline.brackets=對齊多行中括號
wrapping.align.multiline.lt.gt=對齊多行 '<','>'
wrapping.keep.simple.case.inline=將簡單 case 保持在同一行
wrapping.keep.simple.methods.in.one.line=簡單函數在同一行
wrapping.keep.simple.methods.in.one.line.oc=簡單方法和函數在同一行
wrapping.keep.simple.blocks.in.one.line=簡單的 lambda 表達式在同一行
wrapping.keep.simple.blocks.in.one.line.oc=簡單塊和 lambda 在同一行
wrapping.keep.nested.namespaces.in.one.line=將嵌套命名空間保持在同一行
wrapping.keep.directive.at.first.column=指令在第一列
wrapping.brace.placement.class.declaration=在類和結構中
wrapping.property.declaration.oc=@property 聲明
wrapping.try.statement='try'語句
wrapping.catch.on.new.line='catch' 在新行
wrapping.array.initializer=初始值設定項列表
wrapping.array.initializer.oc=集合文字和初始值設定項列表
wrapping.align.multiline.fields.groups=變量組
wrapping.align.in.columns=列中對齊
wrapping.structures.in.one.line=類和結構在同一行
wrapping.before.brace.namespace=在命名空間中
wrapping.ternary.short.inline='a ?: b' 中的 '?:' 不換行
wrapping.try.statement.oc='@try' 語句
wrapping.catch.on.new.line.oc='@catch' 在新行
wrapping.finally.on.new.line.oc='@finally' 在新行
wrapping.array.initializer.lbrace.on.next.line.oc=在'{'、'[' 后換行
wrapping.array.initializer.rbrace.on.next.line.oc=將 '}'、']' 置於新行
wrapping.method.brace.placement=在方法中
wrapping.function.brace.placement=在函數中
wrapping.block.brace.placement=在 lambda 中
wrapping.block.brace.placement.oc=在塊和 lambda 中
wrapping.method.parameters.align.by.colons=通過冒號對齊
wrapping.method.call.arguments.special.dictionary.pairs.treatment=特殊 NSDictionary 初始化處理
wrapping.indent.template.body.if.wrapped=若換行則縮進模板主體
wrapping.new.line.after.colon=在 ':' 后換行
wrapping.new.line.before.colon=將 ':' 置於新行
wrapping.new.line.never=從不
wrapping.new.line.always=始終
wrapping.new.line.if.long=如果過長
align.dictionary.values=對齊列中的字典值
align.init.list.values=對齊列中的初始值設定項列表值
space.within.empty.code.blocks=空代碼大括號
space.within.template=在 <...> 內
space.within.empty.diamond=在空 <> 內
space.within.template.double.gt=在模板中防止 >> 串聯
space.within.bracket=數組中括號
space.within.array.initializer.braces=初始值設定項列表大括號
space.within.array.empty.initializer.braces=空初始值設定項列表大括號
space.within.array.initializer.braces.oc=集合文字和初始值設定項列表大括號
space.within.array.empty.initializer.braces.oc=空集合文字和初始值設定項列表大括號
space.within.function.declaration.parentheses=函數聲明圓括號
space.within.empty.function.declaration.parentheses=空函數聲明括號
space.within.function.call.parentheses=函數調用圓括號
space.within.empty.function.call.parentheses=空函數調用括號
space.within.lambda.capture.list.brackets=Lambda 捕獲列表中括號
space.within.empty.lambda.capture.list.brackets=空 lambda 捕獲列表中括號
space.within.catch.parentheses.oc='@catch' 圓括號
space.within.synchronized.parentheses.oc='@synchronized' 括號
space.within.protocols.brackets.oc=協議列表中括號
space.within.property.attributes.parentheses.oc='@property' 特性括號
space.within.method.return.type.parentheses.oc=方法返回類型括號
space.within.method.parameter.type.parentheses.oc=方法形參類型括號
space.within.send.message.brackets.oc=發送消息中括號
space.within.template.declaration=在模板聲明中
space.within.template.inst=在模板實例化中
space.within.class=在類/結構中
space.before.initialization.lists.colon=構造函數初始化列表冒號之前
space.after.initialization.lists.colon=構造函數初始化列表冒號之後
space.before.lt.template=在 '<' 前面
space.before.function.call.parentheses=函數調用圓括號
space.before.function.parentheses=函數聲明圓括號
space.before.class.lbrace=類/結構左大括號
space.before.method.lbrace=函數左大括號
space.before.method.lbrace.oc=方法/函數左大括號
space.before.namespace.lbrace=命名空間左大括號
space.before.init.list.lbrace=初始值設定項列表左大括號
space.before.superclass.colon=基類冒號之前
space.before.pointer.in.declaration=聲明中的 '*' 之前
space.before.reference.in.declaration=聲明中的 '\\&' 之前
space.before.catch.parentheses.oc='@catch' 圓括號
space.before.try.lbrace.oc='@try' 左大括號
space.before.catch.lbrace.oc='@catch' 左大括號
space.before.finally.lbrace.oc='@finally' 左大括號
space.before.synchronized.lbrace.oc='@synchronized' 左大括號
space.before.catch.keyword.oc='@catch' 關鍵字
space.before.finally.keyword.oc='@finally' 關鍵字
space.before.synchronized.parentheses.oc='@synchronized' 括號
space.before.autorelease.pool.lbrace.oc='@autoreleasepool' 左大括號
space.before.category.parentheses.oc=類別括號之前
space.before.protocols.brackets.oc=協議列表中括號之前
space.before.chained.send.message.oc=鏈式消息發送之前
space.before.property.attributes.parentheses.oc='@property' 特性括號
space.before.dictionary.literal.colon=位字段中的冒號之前
space.before.dictionary.literal.colon.oc=字典文字 'key:value' 對中的冒號和位字段之前
space.after.superclass.colon=基類冒號之後
space.after.structures.rbrace=結構中的右大括號之後
space.after.pointer.in.declaration=聲明中的 '*' 之後
space.after.reference.in.declaration=聲明中的 '\\&' 之後
space.after.reference.in.rvalue=取消引用和 address-of 之後
space.after.method.return.type.parentheses.oc=方法返回類型括號之後
space.after.method.parameter.type.parentheses.oc=方法形參類型括號之後
space.after.visibility.sign.in.method.declaration.oc=方法聲明中的 +/- 之後
space.after.colon.in.selector.oc=選擇器中的冒號之後
space.after.cup.in.blocks.oc=塊中的 '^' 之後
space.after.dictionary.literal.colon=位字段中的冒號之後
space.after.dictionary.literal.colon.oc=字典文字 'key:value' 對中的冒號和位字段之後
space.between.adjacent.brackets=在相同類型的中括號之間保持空格
space.between.operator.punctuator='operator' 關鍵字和標點符號之間
space.discharged.short.ternary.operator='?' 與 'a ? : b' 中的 ':' 之間空格
space.around.relational.operators=關係運算符 (<, >, <=, >=, <=>)
space.around.shift.operators=移位運算符 (<<, >>)
space.around.lambda.arrow='->' 在返回類型中
space.around.pm.operators=指針成員運算符(->、 .、->*、.*)
blank.lines.before.includes=包含之前:
blank.lines.after.includes=包含之後:
blank.lines.around.classes=類/結構周圍:
blank.lines.after.class.header=類/結構頭之後:
blank.lines.around.member.variable=環繞字段:
blank.lines.around.member.variable.oc=實例變量/字段周圍:
blank.lines.around.global.variable=全局變量周圍:
blank.lines.around.function.declaration=函數聲明周圍:
blank.lines.around.function.declaration.oc=方法/函數聲明周圍:
blank.lines.around.function.definition=函數定義周圍:
blank.lines.around.function.definition.oc=方法/函數定義周圍:
blank.lines.before.function.body=函數主體之前:
blank.lines.before.function.body.oc=方法/函數主體之前:
completion.press.keyboard.shortcut.for.all.methods.selectors=為所有方法選擇器再次按 {0}
completion.press.keyboard.shortcut.to.filter.results.by.type=按 {0} 按類型篩選結果
completion.press.keyboard.shortcut.for.non.imported.symbols=為未導入的符號再次按 {0}
completion.press.keyboard.shortcut.for.global.symbols=為全局符號再次按 {0}
completion.press.shortcut.again.for.non.public.members=為非 public 成員 {1, choice, 0#|1#再次} 按 {0}
completion.press.shortcut.again.for.non.imported.members=為非導入的成員和 NSObject 類別的成員 {1, choice, 0#|1#再次}按 {0}
collapse.ivars=實例變量
collapse.synthesizes=合成語句
collapse.localized.strings=已本地化的字符串
collapse.multiline.comments=多行注釋
collapse.block.expressions.oc=塊和 lambda
collapse.block.expressions=Lambda
collapse.conditionally.non-compiled=有條件的未編譯代碼
collapse.template.param.list=模板形參
collapse.new.line.before.lbrace=如果收起，則在 '{' 之前用空格代替換行
color.this.keywords='this' 關鍵字
color.preprocessor.directive=預處理程序//指令
color.preprocessor.path=預處理程序//頭路徑
color.format.string.token=字符串實參中的格式說明符
color.conditionally.non-compiled=有條件的未編譯代碼
color.macro.name=宏名稱
color.macro.parameter=宏形參
color.global.variable=全局變量
color.extern.variable=extern 變量
color.struct.union.oc=結構/枚舉/聯合
color.struct.union=類/結構/枚舉/聯合
color.struct.field=結構字段
color.concept=概念
color.template.type=模板類型
color.template.value=模板值
color.namespace=命名空間
color.enum.const=枚舉常量
color.function.declaration=函數聲明
color.function.call=函數調用
color.overloaded.operator=大括號和運算符//重載運算符
color.typedef=Typedef
color.label=標籤
color.dependent_code=依賴代碼
color.deduction_guide=推導指南
color.this.keywords.oc='self'、'super'、'this' 關鍵字
color.instance.variable.oc=實例變量
color.method.declaration.oc=方法聲明
color.method.call.oc=方法調用
color.property.oc=屬性
color.property.attribute.oc=屬性特性
color.class.reference.oc=類
color.protocol.reference.oc=協議
color.generic.parameter.oc=泛型形參
indent.namespace=縮進命名空間成員
indent.interface.protocol=縮進 '@interface' 和 '@protocol' 成員
indent.not.ivar=實例變量列表除外
indent.implementation=縮進 '@implementation' 成員
indent.visibility.keywords=縮進類/結構中的可見性關鍵字
indent.block=在 lambda 中縮進
indent.block.oc=在塊和 lambda 中縮進
indent.c.struct=縮進純結構成員和枚舉
indent.class=縮進類成員
indent.class.oc=縮進 C++ 類成員
indent.preprocessor.directive=預處理程序指令縮進
indent.preprocessor.directive.as.code=遵循代碼縮進
#indent.preprocessor.directive.after.hash=Indent after #
inline.handler.check.for.validness=正在驗證…
checkbox.block.comment.indent=在塊注釋中縮進新行
override.implement.show.no.optional.members=顯示可選成員(無可選項)
override.implement.show.only.optional.members=顯示可選成員(僅可選項)
override.implement.show.no.synthesized.accessors=顯示合成訪問器(無訪問器)
override.implement.show.only.synthesized.accessors=顯示合成訪問器(僅訪問器)
override.implement.cpp.action.title=重寫/實現函數
override.implement.cpp.action.name=重寫函數…
override.implement.cpp.action.memberChooserTitle=選擇要重寫/實現的函數
override.implement.cpp.action.noMember={0} 沒有要重寫/實現的函數
override.implement.cpp.action.noParent=沒有要重寫/實現的函數
override.implement.cpp.action.insertOverride=插入“override”特性(&I)
override.implement.cpp.action.showNonVirtual=顯示非虛擬函數(&N)
override.implement.cpp.action.insertVirtualWithOverride=將“virtual”特性與“override”一起插入
implement.cpp.action.name=實現函數…
implement.cpp.action.memberChooserTitle=選擇要實現的函數
implement.cpp.action.noMember={0} 沒有要實現的函數
implement.cpp.action.noParent=沒有要實現的函數
changeSignature.usages.cantBeUnnamed=形參 {0} 已被使用，不能取消命名
changeSignature.usages.cantBeRemoved=形參 {0} 已被使用，不能移除
changeSignature.usages.cantConvertSelectorToFuncBlock=無法將選擇器表達式轉換為函數/塊
changeSignature.usages.cantConvertToBlock=無法轉換為塊:
changeSignature.usages.cantConvertLanguage=無法轉換 {0} 代碼中的用法
#changeSignature.usages.ambiguousReference=Function {0} is ambiguously referenced
changeSignature.usages.noUsagesFound=找不到用法
changeSignature.usages.moreThan1Found=找到超過 1 個用法
changeSignature.usages.usageInsideFunction=用法在函數/方法內部
changeSignature.usages.functionHasSeveralDefinitions=函數 ''{0}'' 具有多個定義
changeSignature.usages.atLeasTwoParams=至少兩個形參的名稱為 ''{0}''
changeSignature.usages.conflictsWithNewParameter={0} 與新形參衝突
changeSignature.usages.unrelatedSelector=可能不相關的同名選擇器將被重命名
changeSignature.usages.willConflictWith={0} 將與 {1} 衝突
changeSignature.usages.willConflictWithMethod={0} 將與 {1} 中的方法衝突
changeSignature.targetNotFound=文本光標應置於函數、方法或塊處
changeSignature.dialog.containing.class=包含類:
changeSignature.dialog.callable.type=可調用類型:
changeSignature.parameter.selector.part=選擇器部分:
rename.renameAssociatedFiles=同時重命名關聯的文件?
rename.renameContainingFile=同時重命名包含文件?
rename.renameAssociatedClass=同時重命名關聯的類/結構
find.existing.operators.progress.title=正在搜索現有的運算符
generate.definitions.intention.familyName=生成定義
generate.definitions.intention.outsideText=生成定義
generate.definitions.intention.inlineText=就地生成定義
generate.definitions.action.name=生成定義…
generate.definitions.action.title=生成定義
generate.definitions.action.memberChooserTitle=選擇要為其生成定義的函數
generate.definitions.action.noParent=沒有要為其生成定義的函數
generate.definitions.action.noMembers={0} 沒有要為其生成定義的函數
generate.definitions.quickfix.inlineText=就地為 {0} 生成定義
generate.definitions.quickfix.outsideText=為 {0} 生成定義
generate.definitions.progress.text=正在查找現有定義…
generate.comparison.operators.action.title=生成比較運算符
generate.comparison.operators.action.title.eq=生成相等運算符
generate.comparison.operators.action.title.rel=生成關係運算符
generate.comparison.operators.member.chooser.title=選擇要使用的字段
generate.comparison.operators.as.member.option=作為類成員生成(&M)
generate.comparison.operators.use.std.tie=使用 std::&tie
generate.comparison.operators.additional.eq.option=將 != 與 == 一起生成(&W)
generate.comparison.operators.additional.eq.option.desc=將 != 與 == 一起生成
generate.comparison.operators.additional.rel.option=將 >、<=、>= 與 < 一起生成(&W)
generate.comparison.operators.additional.rel.option.desc=將 >、<=、>= 與 < 一起生成
generate.comparison.operators.usages.all.defined=所有運算符均已定義。
generate.comparison.operators.usages.some.defined=部分運算符已定義。
generate.comparison.operators.usages.existing.text=現有運算符
generate.getter.add.prefix=將 get/is 前綴添加到 getter
generate.setter.add.prefix=將 set 前綴添加到 setter
generate.stream.output.action.title=生成流輸出運算符
generate.stream.output.member.chooser.title=選擇要使用的字段
generate.stream.output.usages.all.defined=流輸出運算符已定義
generate.stream.output.usages.existing.text=現有運算符
generate.configurable.retain.parameters=在 initWith 中保留對象形參…
generate.configurable.use.property.setters=在 initWith 中使用屬性 setter…
generate.configurable.put.ivars=盡可能將 ivars 放入實現
generate.configurable.semicolon.after.method=實現中方法簽名後的分號
generate.configurable.use.nsinteger.and.cgfloat=在引入變量中使用 NSInteger 和 CGFloat
generate.configurable.instance.variable.prefix=實例變量的前綴:
generate.configurable.instance.variable.suffix=實例變量的後綴:
generate.configurable.add.brief.tag=添加 @brief 標記
generate.configurable.const.volatile.placement=const/volatile 限定符位置
generate.configurable.top.level.declarations.order=頂層聲明順序
generate.configurable.ivars.release.style=Ivars 釋放樣式(對於 'dealloc')
generate.configurable.ivars.generation=為屬性生成 ivar 聲明
generate.configurable.ivars.generation.always=始終生成
generate.configurable.ivars.generation.never=從不生成
generate.configurable.ivars.generation.ask=詢問
generate.configurable.tag.prefix.comments=行注釋中的標記前綴
generate.configuralble.tag.prefix.block.comments=塊注釋中的標記前綴
generate.configurable.documentation.title=文檔注釋
inspections.templateArguments.tooFew=模板實參過少，應為 {0} 個
inspections.templateArguments.tooFewAtLeast=模板實參過少，應為至少 {0} 個
inspections.templateArguments.tooMany=模板實參過多，應為 {0} 個
inspections.templateArguments.tooManyAtMost=模板實參過多，應為至多 {0} 個
inspections.templateArguments.valueInsteadOfType=應為值而不是類型
inspections.templateArguments.typeInsteadOfValue=應為類型而不是值
inspections.typeChecks.volatileConflict=正在將非 volatile 結構分配至 volatile 結構
inspections.duplicate.explicitInstantiation=重複的顯式實例化
inspections.typeChecks.neitherNumericNorPointer=類型 ''{0}'' 的表達式既不是數字也不是指針
inspections.typeChecks.notNumeric=類型 ''{0}'' 的表達式不是數字
inspections.fileChecks.outOfProject=此文件不屬於任何項目目標；代碼洞察功能可能無法正常工作。
inspections.fileChecks.allContextsUnloaded=編制索引已對此目標的所有可用解析上下文禁用；代碼洞察功能可能無法正常工作。
inspections.fileChecks.sourceTooLarge=文件大小({0})超出了為 {1} 配置的限制({2})。代碼洞察功能不可用。
inspections.fileChecks.headerTooLarge=文件包含長度({0})超出為 {1} 配置的限制({2})的內聯頭({3})。頭未解析。
inspections.fileChecks.headerTooLargePlatform=文件包含長度({0})超出配置限制({1})的內聯頭({2})。頭未解析。
checkbox.allow.import.in.completion=在補全中自動導入
group.option.predefine=在 .m 內的 .h/Import 中預聲明 
group.option.import=在 .h 中導入
progressbar.long.resolve.description=解析操作需要更多時間…\n如果您取消，則依賴於解析的編輯器操作將不可用
action.invalid.title=無效
change.signature.convert.action=選擇要轉換為{0}的實現
header.source.looking.for.the.best.file=正在查找關聯文件
resolve.contexts.select.automatically=自動選擇
oc.inlay.hints.blacklist.pattern.explanation=<html> 要禁用方法的提示，請使用相應模式: <p> <code><b>(*info)<b></code> - 形參名稱以 info 結尾的單形參方法<br> <code><b>(key, value)<b></code> - 具有形參鍵和值的方法<br> <code><b>*::put(key, value)<b></code> - 具有鍵和值形參的 put 方法<br> </p> </html>
oc.inlay.hints.show.hints.for.enum.constants=顯示枚舉常量提示
oc.inlay.hints.show.hints.for.constructors=顯示構造函數表達式提示
oc.inlay.hints.show.amp.nonconst.references=為非常量引用顯示 '\\&'
include.cpp.message='#include <C++>' 一個面向對 C++ 感興趣的開發者的全球性、包容性和多元化社區
include.cpp.url=https://www.includecpp.org/
include.cpp.intention.text=了解詳情
usage.properties.search.message.delete=也要刪除 {0} 嗎?
usage.properties.search.message.find.usages=也要查找 {0} 的用法嗎?
usage.properties.search.title=屬性搜索
usage.instance.variables.search.message.delete=也要刪除 {0} 嗎?
usage.instance.variables.search.message.find.usages=也要查找 {0} 的用法嗎?
usage.instance.variables.search.title=實例變量搜索
usage.method.search.title=方法搜索
usage.method.search.message.delete={0}\n\n要刪除基{1}嗎?
usage.method.search.message.find.usages={0}\n\n要查找基{1}的用法嗎?
usage.delete.out.of.project.title=警告
usage.delete.out.of.project.message={0} 要繼續執行重構嗎?
usage.overrides.message={0} 重寫 {2} 中的 {1}。
usage.overrides.out.of.project.message={0} 重寫項目外的 {2} 中的 {1}。
usage.include.property.checkbox.text=包含 {0}
usage.include.ivar.checkbox.text=包含 {0}
usage.include.derived.classes.checkbox.text=包含派生類
switch.header.source.popup.title=轉到頭/源
switch.header.source.no.results=無相關文件
command.line.parser.unknown.exception=命令行解析期間出錯
command.line.parser.cancellation.exception=命令行解析被中斷
command.line.parser.invalid.exception=無法解析命令行:\n{0}\n選項 #{1} 中出錯: ''{2}''
configurable.OCGenerateCodeConfigurable.display.name=代碼生成
abstract.extract.dialog.class.name={0} 名稱:
abstract.extract.dialog.unable.create.file=無法創建文件
browse.include.hierarchy.action=導入層次結構
escalate.visibility=升級可見性
escalate.visibility.description=是否要升級以下成員的可見性?
dump.file.symbol.stats=文件符號統計信息
dump.symbol.stats=符號統計信息
highlighter.change.file.length.limit=更改最大文件長度
highlighter.change.file.length.limit.input=以字符為單位輸入 {0} 文件的新最大長度
highlighter.max.file.length.title=最大文件長度
if.responds.to.surround.error.hint=所選代碼中沒有發送消息表達式
quickfixes.implement.missing.getter=實現缺少的 getter 方法
quickfixes.implement.missing.setter=實現缺少的 setter 方法
quickfixes.import.symbol=導入符號
quickfixes.make.function.virtual=使函數為虛擬
quickfixes.make.property.dynamic=使 {0} 為 @dynamic
quickfixes.synthesize=合成{0}
move.dialog.move.members.to.class=將成員移至類(現有或新的):
move.dialog.move.declarations.to.file=將聲明移至文件(現有或新的):
move.dialog.put.to.namespace=置於命名空間(現有或新的):
move.dialog.move.declarations=移動聲明
move.dialog.destination=目標:
move.dialog.target.file.does.not.exist=目標文件 ''{0}'' 尚不存在。
move.dialog.create.new.file=創建新文件
move.dialog.create.new.class=創建新類
move.processor.skip=跳過
push.down.members.dialog=將{0}的成員下推至:
push.down.dialog.searching.inheritors=搜索繼承者
resolve.show.related.contexts=僅顯示相關上下文
resolve.show.all.contexts=顯示所有上下文…
symbol.table.activity.building.symbols=正在構建符號…
symbol.table.activity.loading.symbols=正在加載符號…
symbol.table.activity.updating.symbols=正在更新符號…
symbol.table.activity.loading.header.maps=正在加載標頭映射…
symbol.table.dump.stats.action=統計信息寫入{0}
# action names
action.CIDR.DebugDumpBuildingSymbols.text=C/C++: 轉儲符號構建狀態
action.CIDR.Lang.Format.Extractor.text=提取代碼格式
action.CIDR.Lang.DropPsiForOpenedFiles.text=刪除打開的文件的 PSI
action.CIDR.Lang.RemoveBodiesAndComments.text=移除函數主體和注釋
action.CIDR.Lang.DumpFileSymbolStats.text=轉儲文件符號統計信息
action.CIDR.Lang.DumpSymbolStats.text=轉儲常規符號統計信息
action.CIDR.Lang.CompactSymbols.text=更新/壓縮符號
action.CIDR.Lang.ImportsHierarchy.text=導入層次結構
action.CIDR.Lang.ObjC.GenerateSharedInstance.text=+sharedInstance
action.CIDR.Lang.ObjC.GenerateSharedInstance.description=生成共享實例
action.CIDR.Lang.ObjC.GenerateDescription.text=-描述…
action.CIDR.Lang.ObjC.GenerateDescription.description=從類成員生成 -description
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.text=-isEqual: 和 -hash…
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.description=從類成員生成 -isEqual: 和 -hash
action.CIDR.Lang.ObjC.GenerateCopy.text=-copyWithZone:…
action.CIDR.Lang.ObjC.GenerateCopy.description=從類成員生成 -copyWithZone:
action.CIDR.Lang.ObjC.GenerateEncode.text=-init/encodeWithCoder:…
action.CIDR.Lang.ObjC.GenerateEncode.description=從類成員生成 -encodeWithCoder: 和 initWithCoder:
action.CIDR.Lang.ObjC.GenerateInitWith.text=-initWith…
action.CIDR.Lang.ObjC.GenerateInitWith.description=從類成員生成 -initWith…
action.CIDR.Lang.Cpp.GenerateDefinitions.text=生成定義…
action.CIDR.Lang.Cpp.GenerateDefinitions.description=生成定義
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.text=流輸出運算符
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.description=生成流輸出運算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.text=關係運算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.description=生成關係運算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.text=相等運算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.description=生成相等運算符
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.text=Getter 和 Setter
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.description=為字段生成 getter 和 setter 函數
action.CIDR.Lang.Cpp.GenerateSetter.text=Setter
action.CIDR.Lang.Cpp.GenerateSetter.description=為字段生成 setter 函數
action.CIDR.Lang.Cpp.GenerateGetter.text=Getter
action.CIDR.Lang.Cpp.GenerateGetter.description=為字段生成 getter 函數
action.CIDR.Lang.Cpp.GenerateDestructor.text=析構函數
action.CIDR.Lang.Cpp.GenerateDestructor.description=生成析構函數
action.CIDR.Lang.Cpp.GenerateConstructor.text=構造函數
action.CIDR.Lang.Cpp.GenerateConstructor.description=從類成員生成構造函數
action.CIDR.Lang.ObjC.Synthesize.text=@synthesize…
action.CIDR.Lang.ObjC.Synthesize.description=生成合成變量和實例變量(可選)
action.CIDR.Lang.ObjC.DeclareMembers.text=聲明成員…
action.CIDR.Lang.ObjC.DeclareMembers.description=聲明接口或私有類別中的類成員
action.CIDR.Lang.ObjC.ConvertToIvar.text=轉換為實例變量…
action.CIDR.Lang.ObjC.ConvertToIvar.description=將屬性轉換為實例變量
action.CIDR.Lang.ObjC.ConvertToProperty.text=轉換為屬性…
action.CIDR.Lang.ObjC.ConvertToProperty.description=將實例變量轉換為屬性
action.CIDR.Lang.ObjC.ConvertToBlock.text=轉換為塊…
action.CIDR.Lang.ObjC.ConvertToBlock.description=轉換為塊
action.CIDR.Lang.ObjC.ConvertToFunction.text=轉換為函數…
action.CIDR.Lang.ObjC.ConvertToFunction.description=轉換為函數
action.CIDR.Lang.ObjC.ConvertToMethod.text=轉換為方法…
action.CIDR.Lang.ObjC.ConvertToMethod.description=轉換為方法
action.CIDR.Lang.ObjC.ExtractCategory.text=類別…
action.CIDR.Lang.ObjC.ExtractCategory.description=將成員提取到新類別
action.CIDR.Lang.ObjC.ExtractProtocol.text=協議…
action.CIDR.Lang.ObjC.ExtractProtocol.description=將成員提取到新協議
action.CIDR.Lang.ObjC.ExtractSubclass.text=子類…
action.CIDR.Lang.ObjC.ExtractSubclass.description=將成員提取到新子類
action.CIDR.Lang.ObjC.ExtractBlock.text=塊形參…
action.CIDR.Lang.ObjC.ExtractBlock.description=提取塊形參
action.CIDR.Lang.Cpp.ExtractLambda.text=Lambda 形參…
action.CIDR.Lang.Cpp.ExtractLambda.description=提取 Lambda 形參
action.CIDR.Lang.IntroduceTypedef.text=Typedef…
action.CIDR.Lang.IntroduceTypedef.description=引入 Typedef
action.CIDR.Lang.IntroduceDefine.text=定義…
action.CIDR.Lang.IntroduceDefine.description=引入 Define
action.CIDR.Lang.IntroduceParameter.text=形參…
action.CIDR.Lang.IntroduceParameter.description=引入形參
action.CIDR.Lang.ObjC.IntroduceProperty.text=屬性…
action.CIDR.Lang.ObjC.IntroduceProperty.description=引入屬性
action.CIDR.Lang.ObjC.IntroduceIvar.text=實例變量…
action.CIDR.Lang.ObjC.IntroduceIvar.description=引入實例變量
action.CIDR.Lang.IntroduceConstant.text=常量…
action.CIDR.Lang.IntroduceConstant.description=引入常量
action.CIDR.Lang.IntroduceVariable.text=變量…
action.CIDR.Lang.IntroduceVariable.description=引入變量
action.CIDR.Lang.SwitchHeaderSourceDebug.text=調試頭/源
action.CIDR.Lang.SwitchHeaderSource.text=頭文件/源碼
action.CIDR.Lang.Wrap.By.Pragma.Region=#pragma region...endregion
action.CIDR.Lang.goto.definition.declaration=轉到定義/聲明
action.CIDR.Lang.goto.super.definition=超定義(&U)
action.CIDR.Lang.goto.definition=定義(&E)
loading.module.maps=正在加載模塊映射…
saving.module.maps=正在保存模塊映射…
building.module.maps=正在構建模塊映射…
processing.module.maps=正在處理模塊映射…
loading.headers.search.roots=正在加載標頭搜索根…
goto.definition.settings.title=前往聲明或用法
goto.definition.settings.toggle.assoc.title=對包含預聲明的符號調用時:
goto.definition.settings.toggle.assoc.on=跳轉到預聲明
goto.definition.settings.toggle.assoc.off=顯示用法彈出窗口
goto.symbol=轉到
goto.symbol.ellipsis=轉到…
goto.related.symbol.name1=轉到定義
goto.related.symbol.name2=轉到 ''{1}'' 的 {0}
goto.related.symbol.name3=轉到 {0} 的預定義
goto.related.symbol.name4=轉到 {0} 的定義
goto.related.symbol.name5=轉到 {0} 的聲明
goto.related.symbol.name6=轉到相關 {0}
goto.super.type.name1=轉到 {1} 中的超 {0}
goto.super.type.name2=轉到 {0} 中的基函數
goto.super.type.name3=轉到超類型
goto.subclass=轉到子類
goto.overridden=轉到重寫 {0}...
goto.overridden.methods=轉到重寫方法...
goto.overridden.functions=轉到重寫函數...
saving.symbols=正在保存符號…
progress.text.updating.symbols=正在更新符號…
inspection.message.function.not.implemented={0} 未實現
command.name.add.parameter.to.function Object() { [native code] }=將形參添加到構造函數
dialog.title.select.function Object() { [native code] }.to.update=選擇要更新的構造函數
command.name.add.parameter.to.initwith=將形參添加到 'initWith…'
dialog.title.select.initwith.method.to.update=選擇要更新的 'initWith…' 方法
dialog.message.objc.do.you.want.to.generate.instance.variables.for.chosen.properties=要為所選屬性生成實例變量嗎?
dialog.title.objc.generate.instance.variables=生成實例變量
dialog.message.do.you.want.to.move.class.member.definitions=要移動類成員定義嗎?
dialog.title.move.refactoring.adding.imports=正在添加 import
filetype.asm.description=程序集語言文件
filetype.qt.ui.designer.form.description=Qt UI Designer 表單
statement.name=語句
expression.name=表達式
declaration.name=聲明

surround.with.block.expression.template=^{ return expr; }
surround.with.do.while.template=do / while
surround.with.for.template=for
surround.with.while.template=while
surround.with.if.else.template=if / else
surround.with.if.template=if
surround.with.not.expr.template=!(expr)
surround.with.parenthesis.template=(expr)
surround.with.if.respondsToSelector.template=if respondsToSelector
refactoring.dialog.no.target.file.selected=未選擇目標文件
refactoring.dialog.file.name.invalid=文件名無效
refactoring.dialog.file.not.located.inside.project=文件“{0}”不在項目內部
refactoring.dialog.source.and.target.should.be.different=源和目標應該不同
refactoring.dialog.target.namespace.name.invalid=目標命名空間名稱無效
refactoring.dialog.target.ns.is.part.of.qualified.ns=目標命名空間是限定命名空間的一部分
refactoring.dialog.can.t.move.to.itself=無法將 {0} 移至自身
inspection.name.is.never.used={0} 從未使用

element.description.provider.symbol.of.parent={1} 的 {0}
element.description.provider.predefinition.of={0} 的預定義

qdoc.definition=定義:
qdoc.declared.in=聲明位置:
qdoc.replacement=替換:
qdoc.description.copied.from=描述複製自:

formatter.item.allman.braces=Allman 大括號
formatter.item.kr.braces=K\\&R 大括號
formatter.item.whitesmiths.braces=Whitesmiths 大括號
formatter.item.stroustrup.braces=Stroustrup
formatter.title.code.generation=代碼生成

settings.title.objective.c.class.order=Objective-C 類順序
settings.prefix.must.start.with.letter.or.symbol=前綴必須以字母或 '_' 符號開頭
settings.hint.choice.prefix.suffix.must.contain.only.letters.or.digits.or.symbols={0, choice, 0#前綴|1#後綴}必須只包含字母或數字或 '_' 符號
settings.title.naming.convention=命名慣例
settings.naming.convention=命名慣例
resolve.contexts.all.contexts=已列出所有項目上下文
resolve.contexts.available=可用解析上下文
resolve.contexts.current.file=當前 {0} 文件在 ''{1}'' 的上下文中解析
resolve.contexts.file.resolved.in=此文件將在所選上下文中解析
resolve.contexts.loading=正在加載解析上下文…
resolve.contexts.name=解析上下文
resolve.contexts.no.context=<無上下文>
resolve.contexts.prefix.no.context=當前文件無解析上下文
resolve.contexts.prefix=上下文
resolve.contexts.unindexed.contexts=未索引的上下文
hmap.description={0} 頭映射

search.scope.project.source.files=項目源文件
search.scope.project.non.source.files=項目非源文件

header.search.root.custom.headers=自定義頭
header.search.root.frameworks=框架
header.search.root.explicit.frameworks=顯式框架

find.usages.unknown.type=未知

switch.header.source.separator.headers=頭
switch.header.source.separator.sources=源
new.definition.dialog.title.create.new.function Object() { [native code] }=創建新構造函數
new.definition.dialog.title.create.new.function=創建新函數
new.definition.button.create=創建
new.definition.dialog.title.create.new.method=創建新方法
action.context.file.name=文件 ''{0}''
oc.declare.members.implementation.undeclared=實現(未聲明)
dialog.message.some.members.are.defined=部分已定義
dialog.message.all.members.are.defined=全部均已定義
tab.title.existing=現有
label.copy.depth=深度
copy.depths.option.deep=深層
copy.depths.option.shallow=淺層
button.generate=生成
other.categories.and.inherited.members=其他類別和繼承的成員
action.show.inherited.text=顯示繼承項
action.show.inherited.members.members.in.other.categories.description=顯示繼承的成員和其他類別的成員
polymorphic.call=(多態調用)
label.or.in.objective.c.code=或在 Objective-C 代碼中

symbol.kind.name.uppercase.type=類型
symbol.kind.name.uppercase.enum.constant=枚舉常量
symbol.kind.name.uppercase.field=字段
symbol.kind.name.uppercase.function=函數
symbol.kind.name.uppercase.function Object() { [native code] }=構造函數
symbol.kind.name.uppercase.parameter=形參
symbol.kind.name.uppercase.global.variable=全局變量
symbol.kind.name.uppercase.built.in.symbol=內置符號
symbol.kind.name.uppercase.local.variable=局部變量
symbol.kind.name.uppercase.exception.variable=異常變量
symbol.kind.name.uppercase.implementation=實現
symbol.kind.name.uppercase.instance.variable=實例變量
symbol.kind.name.uppercase.interface=接口
symbol.kind.name.uppercase.label=標籤
symbol.kind.name.uppercase.macro=宏
symbol.kind.name.uppercase.macro.parameter=宏形參
symbol.kind.name.uppercase.import=導入
symbol.kind.name.uppercase.compatibility.alias=兼容性別名
symbol.kind.name.uppercase.method1=方法
symbol.kind.name.uppercase.block=塊
symbol.kind.name.uppercase.lambda=Lambda
symbol.kind.name.uppercase.property=屬性
symbol.kind.name.uppercase.synthesize.statement=合成語句
symbol.kind.name.uppercase.protocol=協議
symbol.kind.name.uppercase.struct=結構
symbol.kind.name.uppercase.union=聯合
symbol.kind.name.uppercase.enum=枚舉
symbol.kind.name.uppercase.namespace=命名空間
symbol.kind.name.uppercase.type.parameter=類型形參
symbol.kind.name.uppercase.template.parameter=模板形參
symbol.kind.name.uppercase.using=Using
symbol.kind.name.uppercase.localized.string=已本地化的字符串
symbol.kind.name.uppercase.expression=表達式
symbol.kind.name.uppercase.generic.parameter=泛型形參
symbol.kind.name.uppercase.concept=概念
symbol.kind.name.uppercase.keyword=關鍵字
symbol.kind.name.uppercase.file=文件
symbol.kind.name.uppercase.folder=文件夾
symbol.kind.name.uppercase.default=符號

symbol.kind.name.lowercase.type=類型
symbol.kind.name.lowercase.enum.constant=枚舉常量
symbol.kind.name.lowercase.field=字段
symbol.kind.name.lowercase.function=函數
symbol.kind.name.lowercase.function Object() { [native code] }=構造函數
symbol.kind.name.lowercase.parameter=形參
symbol.kind.name.lowercase.global.variable=全局變量
symbol.kind.name.lowercase.built.in.symbol=內置符號
symbol.kind.name.lowercase.local.variable=局部變量
symbol.kind.name.lowercase.exception.variable=異常變量
symbol.kind.name.lowercase.implementation=實現
symbol.kind.name.lowercase.instance.variable=實例變量
symbol.kind.name.lowercase.interface=接口
symbol.kind.name.lowercase.label=標籤
symbol.kind.name.lowercase.macro=宏
symbol.kind.name.lowercase.macro.parameter=宏形參
symbol.kind.name.lowercase.import=導入
symbol.kind.name.lowercase.compatibility.alias=兼容性別名
symbol.kind.name.lowercase.method1=方法
symbol.kind.name.lowercase.block=塊
symbol.kind.name.lowercase.lambda=lambda
symbol.kind.name.lowercase.property=屬性
symbol.kind.name.lowercase.synthesize.statement=合成語句
symbol.kind.name.lowercase.protocol=協議
symbol.kind.name.lowercase.struct=struct
symbol.kind.name.lowercase.union=聯合
symbol.kind.name.lowercase.enum=枚舉
symbol.kind.name.lowercase.namespace=命名空間
symbol.kind.name.lowercase.type.parameter=類型形參
symbol.kind.name.lowercase.template.parameter=模板形參
symbol.kind.name.lowercase.using=using
symbol.kind.name.lowercase.localized.string=已本地化的字符串
symbol.kind.name.lowercase.expression=表達式
symbol.kind.name.lowercase.generic.parameter=泛型形參
symbol.kind.name.lowercase.concept=概念
symbol.kind.name.lowercase.keyword=關鍵字
symbol.kind.name.lowercase.file=文件
symbol.kind.name.lowercase.folder=文件夾
symbol.kind.name.lowercase.default=符號
command.name.codestylesettings.extractor=代碼樣式設置提取程序
symbol.kind.name.uppercase.destructor=析構函數
symbol.kind.name.uppercase.class=類
symbol.kind.name.lowercase.destructor=析構函數
symbol.kind.name.lowercase.class=類
popup.title.element.found.singular={0} (已找到 {1} 元素)
popup.title.elements.found.plural={0} (已找到 {1} 元素)

resource.language.unknown=未知

color.doxygen.comment=注釋//Doxygen//文本
color.doxygen.tag=注釋//Doxygen//標記
color.doxygen.tag.value=注釋//Doxygen//標記值
oc.inlay.hints.type.name=類型
oc.inlay.hints.type.for.variables=變量類型
oc.inlay.hints.type.for.lambdas=Lambda 類型
oc.inlay.hints.type.deduced.return.types=推導的返回類型
oc.inlay.hints.type.main.checkbox=顯示類型提示:
completion.no.suggestions.press.for.not.imported=無建議，對於未導入的成員按 {0}
color.std.initializer.list.oc=大括號和運算符//初始值設定項列表
action.CIDR.Lang.goto.definition.declaration.tooltip=轉到定義/聲明
goto.related.symbol.name1.tooltip=轉到定義
goto.related.symbol.name2.tooltip=轉到 ''{1}'' 的 {0}
goto.related.symbol.name3.tooltip=轉到 {0} 的預定義
goto.related.symbol.name4.tooltip=轉到 {0} 的定義
goto.related.symbol.name5.tooltip=轉到 {0} 的聲明
goto.related.symbol.name6.tooltip=轉到相關 {0}
goto.subclass.title=轉到子類
goto.overridden.title=轉到重寫 {0}
goto.overridden.methods.title=轉到重寫方法
goto.overridden.functions.title=轉到重寫函數
oc.inlay.hints.show.settings=提示設置…
cache.downloader.updating.title=更新緩存
cache.downloader.not.now.option=以後再說
cache.downloader.download.option=下載
cache.downloader.always.download.option=始終下載
oc.inlay.hints.type.obvious.types=明顯類型
checkbox.local.files.with.quotes=自動導入帶引號的本地文件
popup.title.element.found.so.far.singular={0}（目前已找到 {1} 個元素）
popup.title.elements.found.so.far.plural={0}（目前已找到 {1} 個元素）
space.before.colon.in.foreach='for' 冒號之前
space.after.colon.in.foreach='for' 冒號之後
action.CIDR.Lang.QualifiedNames.text=顯示限定名稱
action.CIDR.Lang.QualifiedNames.description=顯示限定名稱