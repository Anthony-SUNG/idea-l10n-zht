jvm.inspections.group.name=JVM 語言

jvm.inspections.unstable.api.usage.display.name=不穩定的 API 用法
jvm.inspections.unstable.api.usage.annotations.list=不穩定的 API 注解:
jvm.inspections.unstable.api.usage.ignore.inside.imports=在導入內忽略
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此項目中聲明的 API
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中聲明
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=重寫方法 ''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=重寫方法 ''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中聲明
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不穩定，因為其簽名引用了標記為 @{3} 的不穩定{1} ''{2}''

jvm.inspections.scheduled.for.removal.future.version=未來版本
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中聲明
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=重寫方法 ''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=重寫方法 ''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中聲明
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已計劃移除，因為其簽名引用了已計劃從 {3} 中移除的{1} ''{2}''

jvm.inspections.unstable.type.used.in.signature.display.name=簽名中使用了不穩定的類型
jvm.inspections.unstable.type.used.in.class.signature.description=類必須使用 ''@{0}'' 注解標記，因為其聲明引用了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必須使用 ''@{0}'' 注解標記，因為其簽名引用了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=字段必須使用 ''@{0}'' 注解標記，因為其類型引用了不穩定的類型 ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已計劃移除的 API 上缺少 '@Deprecated' 注解
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已計劃移除的 API 也必須使用 '@Deprecated' 注解標記
jvm.inspections.must.already.be.removed.api.display.name=API 必須已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必須已在版本 {0} 中移除，但當前版本為 {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API 必須在當前版本 {0} 中移除
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞調用可能會導致線程匱乏
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞調用
jvm.inspections.blocking.method.annotation.blocking=阻塞注解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=添加阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=添加非阻塞注解
jvm.inspections.blocking.method.annotation.configure.empty.text=未添加注解。

jvm.inspections.api.no.extension.display.name=不應擴展類、接口或方法
jvm.inspections.api.no.extension.class.description=不得擴展類 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得實現接口 ''{0}''
jvm.inspections.api.no.extension.interface.extend.description=不得擴展接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得重寫方法 ''{0}''
jvm.inspections.api.override.only.display.name=方法只能重寫
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能重寫

jvm.inspections.dependency.display.name=非法的軟件包依賴項
jvm.inspections.dependency.edit.rules.text=編輯依賴關係規則 "{0} "
jvm.inspections.dependency.edit.rules.family=編輯依賴關係規則
jvm.inspections.dependency.configure.button.text=配置依賴關係規則
jvm.inspections.dependency.violator.problem.descriptor=違反依賴關係規則 ''{0}.''

jvm.inspections.junit.rule.display.name=@Rule/@ClassRule 字段的格式錯誤
jvm.inspections.junit.rule.problem.descriptor=使用 ''@{0}'' 注解的字段應當為 {1}
jvm.inspections.junit.rule.type.problem.descriptor=字段類型應當為 'org.junit.rules.TestRule' 的子類型

jvm.inspections.testonly.display.name=生產代碼中的純測試用法
jvm.inspections.testonly.class.reference=在生產代碼中引用純測試類
jvm.inspections.testonly.field.reference=在生產代碼中引用純測試字段
jvm.inspections.testonly.method.call=在生產代碼中調用純測試方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 對 @TestOnly 代碼意義不大

jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用國際化字符串指定區域設置的情況下調用 <code>String.{0}()</code> #loc
can.t.build.uast.tree.for.file=無法為文件構建 UAST 樹
title.uast=UAST
current.version=當前版本:
dialog.title.choose.annotation=選擇 {0}
jvm.inspection.test.failed.line.display.name=測試中失敗的行
jvm.inspections.source.to.sink.flow.display.name=不安全字符串被傳遞至安全方法
jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 測試中的已廢棄斷言
jvm.inspections.junit5.assertions.converter.problem.descriptor=對來自 ''{0}'' 的 <code>#ref()</code> 的調用應替換為對來自 ''{1}'' 的方法的調用 #loc
jvm.inspections.junit5.assertions.converter.quickfix=替換為 ''{0}'' 方法調用
jvm.inspections.junit5.assertions.converter.familyName=替換為 JUnit 5 兼容調用
jvm.inspections.junit5.converter.display.name=JUnit 4 測試可以為 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref 可以為 JUnit 5 測試
jvm.inspections.junit5.converter.quickfix=遷移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=轉換斷言
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由於存在不兼容的繼承者，類 {0} 無法轉換為 JUnit 5: {1}
jvm.inspections.thread.run.display.name=調用 'Thread.run()'
jvm.inspections.serializable.class.without.serialversionuid.display.name=不帶 'serialVersionUID' 的可序列化類
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> 未定義 'serialVersionUID' 字段 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全的字符串傳遞給安全的方法
jvm.inspections.source.to.sink.flow.passed.unknown=將未知字符串傳遞給安全方法
jvm.inspections.source.to.sink.flow.returned.unsafe=安全方法返回不安全字符串
jvm.inspections.source.to.sink.flow.returned.unknown=安全方法返回未知字符串
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=將 ''{0}'' 標記為需要驗證
jvm.inspections.blocking.method.consider.unknown.context.blocking=考慮未知上下文阻塞
jvm.inspections.blocking.method.problem.wildcard.descriptor=阻塞 {0} 中的調用可能會導致線程匱乏