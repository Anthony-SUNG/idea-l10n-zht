conflicting.annotations.display.name=Guice 注解衝突
conflicting.annotations.problem.descriptor=注解 #ref 與聲明的其他注解衝突 #loc
multiple.binding.annotations.display.name=變量有多個綁定注解
multiple.binding.annotations.problem.descriptor=變量 #ref 有多個綁定注解 #loc
binding.annotation.without.inject.display.name=沒有 @Inject 的綁定注解
binding.annotation.without.inject.problem.descriptor=沒有聲明 @Inject 的綁定注解 #ref #loc
interception.annotation.without.runtime.retention.display.name=沒有運行時保留的截取注解
interception.annotation.without.runtime.retention.problem.descriptor=注解 #ref 沒有運行時保留 #loc
invalid.request.parameters.display.name=@RequestParameters 參數的類型不正確
invalid.request.parameters.problem.descriptor=標記為 #ref 的變量或參數的類型必須為 Map<String, String[]> #loc
invalid.implemented.by.display.name=@ImplementedBy 注解無效
invalid.implemented.by.problem.descriptor=#ref 類未實現注解類 #loc
singleton.injects.scoped.display.name=@Singleton 組件注入范圍組件
singleton.injects.scoped.problem.descriptor=范圍類 #ref 的 @Inject 來自 @Singleton 類 #loc
group.guice.inspections.name=Guice
session.scoped.injects.request.scoped.display.name=@SessionScoped 組件注入 @RequestScoped 組件
session.scoped.injects.request.scoped.problem.descriptor=@RequestScoped 類 #ref 的 @Inject 來自 @SessionScoped 類 #loc
invalid.provided.by.display.name=@ProvidedBy 注解無效
invalid.provided.by.problem.descriptor=#ref 類未提供注解類 #loc
uninstantiable.implemented.by.class.display.name=無法實例化的 @ImplementedBy 類
uninstantiable.implemented.by.class.problem.descriptor=類 #ref 不可實例化，因此不能為 @ImplementedBy #loc
uninstantiable.provided.by.class.display.name=無法實例化的 @ProvidedBy 類
uninstantiable.provided.by.class.problem.descriptor=類 #ref 不可實例化，因此不能為 @ProvidedBy #loc
uninstantiable.binding.display.name=無法實例化的綁定
uninstantiable.binding.problem.descriptor=類 #ref 不可實例化，因此不可綁定 #loc
redundant.to.binding.display.name=冗余綁定
redundant.to.binding.problem.descriptor=與類 #ref 的綁定冗余 #loc
redundant.to.provider.binding.display.name=冗余提供程序綁定
redundant.to.provider.binding.problem.descriptor=與類 #ref 的綁定冗余 #loc
redundant.scope.binding.display.name=冗余范圍綁定
redundant.scope.binding.problem.descriptor=與范圍 #ref 的綁定冗余 #loc
pointless.binding.display.name=無意義的綁定
pointless.binding.problem.descriptor=綁定非必要，可以移除 #loc
unnecessary.static.injection.display.name=不必要的 static 注入
unnecessary.static.injection.problem.descriptor=類 #ref 沒有 static @Inject 成員 #loc
multiple.injected.constructors.for.class.display.name=類有多個 @Inject 構造函數
multiple.injected.constructors.for.class.problem.descriptor=類 #ref 有多個 @Inject 構造函數 #loc
move.binding.scope.to.class.text=將綁定范圍移至類
move.binding.scope.to.class.family.name=將綁定范圍移至類
move.binding.to.class.text=將綁定類移至類
move.binding.to.class.family.name=將綁定移至類
move.provider.binding.to.class.text=將提供程序綁定移至類
move.provider.binding.to.class.family.name=將提供程序綁定移至類
guice.intentions=Guice
new.guice.module.error=無法創建 Guice 模塊
new.guice.module.action.name=創建 Guice 模塊
new.guice.module.name=創建 Guice 模塊: {0}。{1}
new.guice.scope.annotation.error=無法創建 Guice 范圍注解
new.guice.scope.annotation.action.name=創建 Guice 范圍注解
new.guice.binding.annotation.error=無法創建 Guice 綁定注解
new.guice.binding.annotation.action.name=創建 Guice 綁定注解
new.guice.binding.annotation.name=創建 Guice 綁定注解: {0}。{1}
new.guice.method.interceptor.error=無法創建 Guice 方法偵聽器
new.guice.method.interceptor.action.name=創建 Guice 方法偵聽器
new.guice.method.interceptor.name=創建 Guice 方法偵聽器: {0}。{1}
new.guice.provider.error=無法創建 Guice 提供程序
new.guice.provider.action.name=創建 Guice 提供程序
new.guice.provider.name=創建 Guice 提供程序: {0}。{1}
toggle.injection.required.family.name=切換注入
make.injection.optional=將注解設為可選
make.injection.mandatory=將注解設為強制
toggle.required=切換 'optional'
action.group.guice.title=Google Guice
action.group.guice.description=Google Guice 組件
delete.binding=刪除綁定
select.provided.class=選擇要提供的類
GuiceClassAnnotator.popup.title=選擇要導航到的表達式
GuiceClassAnnotator.popup.tooltip.text=導航到 Guice 綁定表達式
gutter.choose.injected.point=選擇注入點
gutter.navigate.to.injection.point=導航到注入點
provider.class.name=提供程序類名:
class.provided=提供的類:
new.guice.provider=新建 Guice 提供程序