#generic
build.message.builder.0.requested.build.stop=構建器 {0} 請求構建停止
build.message.cannot.build.0.because.it.is.included.into.a.circular.dependency.1=無法構建 {0}，因為它處在一個循環依賴關係中({1})
build.message.cannot.determine.build.data.storage.root.for.project.0=無法確定專案 {0} 的構建資料存儲根
build.message.consider.building.whole.project.or.rebuilding.the.module=考慮構建整個專案或重新構建模塊。
build.message.dependency.data.format.has.changed.project.rebuild.required=依賴資料格式已改變，需要重新構建專案
build.message.error.cleaning.compiler.storages=清理編譯器存儲時出錯
build.message.error.cleaning.timestamps.storage=清理時間戳存儲時出錯
build.message.failed.to.delete.output.files.from.obsolete.0.target.1=無法從過時 ''{0}'' 目標刪除輸出檔案: {1}
build.message.failed.to.load.project.configuration.0=載入專案配置失敗: {0}
build.message.insufficient.memory=OutOfMemoryError: 內存不足
build.message.internal.caches.are.corrupted=內部快取損壞或格式過期，需要強制重新構建專案: {0}
build.message.internal.error.0.1=內部錯誤 ({0}): {1}
build.message.output.path.0.intersects.with.a.source.root=輸出路徑 {0} 與源根相交。只有通過構建創建的檔案會被清理。
build.message.perform.full.project.rebuild=請執行完整的專案重新構建(構建 | 重新構建專案)
build.message.problems.clearing.output.files.for.target.0.1=清理目標”{0}“的輸出檔案時出現問題: {1}
build.message.project.rebuild.forced.0=已強制專案重新構建: {0}
build.message.the.build.has.been.canceled=構建已取消
build.message.too.many.modules.require.recompilation.forcing.full.project.rebuild=過多模塊需要重新編譯，強制整個專案重新構建
build.message.unsupported.message.type.0=不支持的消息類型: {0}
builder.0.requested.rebuild.of.module.chunk.1=構建器“{0}”請求重新構建模塊塊“{1}”
builder.name.root=構建
progress.message.cleaning.old.output.directories=正在清理舊輸出目錄…
progress.message.cleaning.output.directories=正在清理輸出目錄…
progress.message.dependency.analysis.found.0.affected.files=依賴分析發現 {0} 個受影響的檔案
progress.message.finished.saving.caches=已完成，正在保存快取…
progress.message.running.after.tasks=正在執行 'after' 任務
progress.message.running.before.tasks=正在執行 'before' 任務

#java
build.message.0.was.used.to.compile.1={0} 用於編譯 [{1}]
build.message.0.was.used.to.compile.1.modules={0} 用於編譯 {1} 模塊
build.message.0.was.used.to.compile.java.sources={0} 用於編譯 java 源
build.message.cannot.compile.a.module.cycle.with.multiple.module.info.files=無法編譯帶有多個 module-info.java 檔案的模塊循環: {0}
build.message.cannot.find.jdk.0.for.module.1=找不到模塊 ''{1}'' 的 JDK ''{0}''
build.message.cannot.find.jdk.for.module.0.1.points.to.2=找不到模塊 ''{0}'' 的 JDK: ''{1}'' 指向 {2}
build.message.class.dependency.information.may.be.incomplete=類依賴項資訊可能不完整。解析生成類 {0} 時出錯
build.message.compilation.failed.errors.0.warnings.1=編譯失敗: 錯誤: {0}；警告: {1}
build.message.internal.error.0=內部錯誤: \n{0}
build.message.jdk.isn.t.specified.for.module.0=沒有為模塊 ''{0}'' 指定 JDK
build.message.missing.content.for.file.0=檔案 {0} 缺少內容
build.message.multiple.encodings.set.for.module.chunk=模塊塊 {0} 的多編碼設定{2, choice, 0#\n“{1}”將被編譯器所用|1#}
build.message.some.modules.with.cyclic.dependencies.0.have.additional.command.line.parameters=某些具有循環依賴關係 [{0}] 的模塊在專案設定中已重寫“附加命令行參數”。\n這些編譯選項已應用於循環中的所有模塊。
build.message.unsupported.compact.compilation.profile.was.requested=已請求緊湊的編譯配置檔案，但是模塊“{0}”的目標平台與 javac 的平台({1})不同\n此類配置不支持編譯配置檔案
build.message.user.specified.option.0.for.1.may.conflict.with.calculated.option=“{1}”的使用者指定選項“{0}”可能會與根據專案設定自動計算的相應選項發生衝突。
build.message.user.specified.option.0.is.ignored.for.1=已對“{1}”忽略使用者指定選項“{0}”。該編譯參數根據專案設定自動設定。
build.message.incremental.annotation.processing.disabled.0=JPS 增量註解進程已禁用。部分重新編譯的編譯結果可能不準確。使用構建進程“{0}”VM 標誌啟用/禁用增量註解處理環境。
progress.message.checking.dependencies.0=正在檢查依賴項… [{0}]
progress.message.checking.sources=正在檢查源
progress.message.marking.0.and.direct.dependants.for.recompilation=正在標記 {0} 和直接依賴項以重新編譯
progress.message.parsing.java.0=正在解析 java… [{0}]
progress.message.updating.dependency.information.0=正在更新依賴項資訊… [{0}]
progress.message.writing.classes.0=正在編寫類… {0}
build.message.modules.0.and.1.must.have.the.same.language.level=模塊 {0} 和 {1} 必須具有相同的語言級別，因為它們之間存在循環依賴關係
build.message.modules.0.and.1.must.have.the.same.additional.command.line.parameters=模塊 {0} 和 {1} 必須指定相同的“附加命令行參數”，因為它們之間存在循環依賴關係
build.message.annotation.processing.is.not.supported.for.module.cycles=模塊循環不支持註解處理。請確保將循環 [{0}] 中的所有模塊排除在註解處理之外
target.description.tests.of.0={0} 的測試
target.description.0.and.1.more={0} 和其他 {1} 個
build.messages.modules.were.fully.rebuilt={1, choice, 1#模塊 {0} 已經|2#模塊 {0} 已經|7#模塊 {0} 和其他 {2} 個已經}完全重新構建，因為專案配置{3, choice, 0#|1#/依賴項}發生變更
build.message.errors.occurred.while.compiling.module.0=編譯模塊 ''{0}'' 時發生錯誤
build.message.compilation.failed.internal.java.compiler.error=編譯失敗: 內部 java 編譯器錯誤
build.message.cannot.start.javac.process.for.0.unknown.jdk.home=無法啟動 {0} 的 javac 進程: 未知 JDK 主路徑。\n請檢查專案配置。

#artifacts
builder.name.artifacts.builder=工件構建器
build.message.archive.0.doesn.t.contain.files.so.it.won.t.be.created=歸檔 ''{0}'' 不包含檔案，所以不會被創建
build.message.cannot.build.0.artifact.it.includes.itself=無法構建 ''{0}'' 工件: {2, choice, 0#其|1#“{1}”工件}將自身包含於輸出布局
build.message.cannot.build.0.artifact.output.path.is.not.specified=無法構建 ''{0}'' 工件: 未指定輸出路徑
build.message.cannot.build.circular.dependency.found.between.0.and.1=無法構建: 在 ''{0}'' 和 ''{1}'' 之間發現循環依賴關係
build.message.cannot.create.0.1=無法創建 ''{0}'': {1}
build.message.cannot.create.manifest.mf.from.0.1=無法從 {0} 創建 MANIFEST.MF: {1}
build.message.cannot.delete.file.0=無法刪除檔案 ''{0}''
build.message.cannot.extract.0.from.1.while.building.2.artifact.3=構建 ''{2}'' 工件時，無法從 ''{1}'' 中提取 ''{0}'': {3}
build.message.deletion.of.outdated.files.stopped=由於太多檔案無法刪除，已停止刪除過時檔案
build.message.manifest.file.0.included.into.archive.does.not.contain.required.attribute=納入歸檔 ''{1}'' 中的清單檔案 ''{0}'' 不包含 ''{2}'' 特性。此類清單檔案無效，並且其內容未納入 JAR 檔案。
progress.message.building.archives=正在構建歸檔…
progress.message.building.artifact.0=正在構建工件 ''{0}''…
progress.message.building.artifact.0.copying.files=正在構建工件 ''{0}'': 正在複製檔案…
progress.message.building.jar.0=正在構建 {0}…
progress.message.copying.archives=正在複製歸檔…
progress.message.deleting.outdated.files=正在刪除過時的檔案…
progress.message.running.0.tasks.for.1.artifact=正在為 ''{1}'' 工件執行{0, choice, 0#預處理|1#完成|2#後處理}任務…

#instrumentation
build.message.cannot.instrument.0.1=無法插樁 {0}: {1}
builder.name.notnull.instrumentation=NotNull 插樁
progress.message.adding.notnull.assertions=正在添加 @NotNull 斷言…

#rmi
build.message.rmi.stub.generation.failed=RMI 存根生成失敗
builder.name.backward.references.indexer=後向引用索引器
progress.message.generating.rmi.stubs=正在生成 RMI 存根…

#dependency resolver
builder.name.maven.dependency.resolver=Maven 依賴項解析器
builder.name.project.dependencies.resolver=專案依賴項解析器
progress.message.resolving.0.library=正在解析 ''{0}'' 庫…
progress.message.resolving.repository.libraries.in.the.project=正在解析專案中的儲存庫庫…
build.message.error.resolving.dependencies.for=解析 {0} 的依賴項時出錯
build.message.unknown.host.0=未知主機: {0}

#resources builder
builder.name.resource.compiler=資源編譯器
progress.message.copying.resources.0=正在複製資源… [{0}]

# intellilang-jps
intellilang.pattern.validator.presentable.name=IntelliLang 模式驗證器
intellilang.pattern.validator.progress.message=正在添加模式斷言…

packaging.jlink.build.task.modules.not.found=找不到 JPMS 模塊
packaging.jlink.build.task.wrong.java.version=使用 jlink 構建執行時鏡像要求 Java 9 或更高版本
packaging.jlink.build.task.unknown.artifact.path=未知工件輸出路徑
packaging.jlink.build.task.run.time.image.deletion.failure=無法刪除現有的執行時鏡像
packaging.jlink.build.task.failure=jlink 任務失敗
action.NotificationAction.JpsCachesDummyProjectComponent.text.disable.property=禁用屬性
action.NotificationAction.JpsCachesDummyProjectComponent.text.dont.ask=不再詢問
action.NotificationAction.JpsOutputLoaderManager.text.update.caches=更新快取
notification.title.git.crlf.config=錯誤的 Git 行尾配置
notification.content.git.crlf.config=沒有為專案正確配置 Git 行尾。便攜式 JPS 快取無法在此類配置下正常工作。
notification.action.git.crlf.config=打開配置描述
notification.title.automatic.project.build.enabled=已啟用自動專案構建
notification.content.make.project.automatically.enabled.affect.caches=JPS 可移植快取尚不支持“自動構建專案”屬性，可能導致專案完全重新構建
notification.content.failed.request.to.cache.server=無法請求快取伺服器: {0}
notification.title.compiler.caches.loader=編譯器快取載入程序
notification.content.update.compiler.caches.failed=更新編譯器快取失敗
progress.text.rolling.back.downloaded.caches=正在回滾已下載的快取
notification.content.update.compiler.caches.completed.successfully.in.s=在 {0} 秒內成功完成編譯器快取更新
progress.text.rolling.back=正在回滾
progress.text.fetching.cache.for.commit=正在提取提交的快取: {0}
notification.title.jps.caches.downloader=Jps 快取下載程序
notification.content.system.contains.up.to.date.caches=系統包含最新快取
notification.content.not.found.any.caches.for.latest.commits.in.branch=在分支中未找到最新提交的任何快取
notification.title.compiler.caches.available=有可用的編譯器快取
notification.content.caches.are.for.commit.commits.prior.to.yours=快取可用於提交，即當前修訂之前的{0} 個{0,choice,1#提交|2#提交}。
notification.content.caches.are.for.current.commit=快取可用於當前版本。
progress.text.clean.output.directories=清理輸出目錄
progress.details.applying.downloaded.caches=正在應用已下載的快取
progress.details.extracting.project.caches=正在提取專案快取
progress.details.extracting.compilation.outputs.for.module=正在提取 {0} 模塊的編譯輸出
progress.details.applying.changes.for.module=正在為 {0} 模塊應用變更
notification.content.internal.authentication.plugin.required.for.correct.work.plugin=必須具備 <a href="https://plugins.jetbrains.com/plugin/14567-jetbrains-internal-authentication">JetBrains Internal Authentication</a>，套件才能正常工作
internal.authentication.plugin.missing.token=意外狀態: 缺少 jetbrains.team 標記。請報告此異常，並執行操作“從 JetBrains.team 注銷”和“登錄 JetBrains.team”作為解決方法
progress.title.updating.compiler.caches=正在更新編譯器快取
progress.text.applying.jps.caches=正在應用 JPS 快取…
progress.text.extracting.downloaded.results=正在提取已下載的結果…
progress.text.calculating.affected.modules=正在計算受影響的模塊
action.JpsUpdateCachesAction.text=更新 JPS 快取
action.JpsForceUpdateCachesAction.text=強制更新 JPS 快取
progress.download.file.text=正在從 ''{1}'' 下載 ''{0}''…
progress.connecting.to.download.file.text=正在連接到 ''{0}''…
progress.downloading.0.files.text=正在下載 {0} {0, choice, 1#檔案|2#檔案}...
error.file.download.failed=無法下載 ''{0}'':\n{1}
notification.content.commits.count.threshold=Should be at least 150 commits for compilation caches download.
notification.content.no.commits.since.latest.compilation=No new commits since last success compilation.