evaluation.error.empty.code.fragment=應為代碼段
evaluation.error.cannot.evaluate.tostring=無法評估 {0}.toString()
evaluation.error.unsupported.expression.type=不支持的表達式類型
evaluation.error.object.is.being.initialized=對象正在初始化
internal.error.locations.of.line=內部錯誤從''{0}''加載調試信息.  此類不能使用斷點.
evaluation.error.inconsistent.debug.info=調試信息不一致
evaluation.error.boolean.value.expected.in.condition=條件中預估值為'boolean'
evaluation.error.boolean.condition.expected=條件中應為 'boolean' 值
evaluation.error.process.exited=無法評估: 進程退出
evaluation.error.stack.frame.unavailable=堆棧幀不可用
evaluation.error.nested.evaluation=評估不支持另一種方法的評估
evaluation.error.sources.out.of.sync=源碼與執行的代碼不對應
evaluation.error.cannot.find.stackframe.source=找不到當前堆棧幀的源類
evaluation.error.cannot.find.source=無法找到 {0} 的源類
evaluation.error.object.collected=已搜集對象
evaluation.error.thread.collected=已收集線程
evaluation.error.array.collected=已收集數組
evaluation.error.thread.resumed=線程已被恢復
evaluation.error.debug.info.unavailable=調試信息不可用
evaluation.error.invalid.expression=無效的表達式 : {0}
evaluation.error.unknown.expression.type=表達式類型未知: {0}
evaluation.error.unknown.expression.operand=表達式操作數未知: {0}
evaluation.error.type.mismatch=類型不匹配
evaluation.error.class.not.loaded=類''{0}''未加載
evaluation.error.thread.not.at.breakpoint=無法評估e: 線程不會在斷點處暫停
evaluation.error.method.exception=方法拋出''{0}''異常.
evaluation.error.surrounded.expression.null=環繞的表達式為null
title.customize.data.views=自定義數據視圖
title.evaluating=評估...
error.native.method.exception=所有幀和包括幀都不是本機的
error.executing.finally=執行 finally 塊時出錯: {0}
error.early.return=早期返回時出錯: {0}
error.throw.exception=拋出異常時出錯: {0}
warning.finally.block.detected=檢測到非空 finally 塊:
button.drop.anyway=不執行
button.execute.finally=執行 finally 塊
drop.frame.error.no.information=有關框架的信息不可用
progress.evaluating=評估{0}
action.resume.thread.text.resume=恢復
action.interrupt.thread.text=中斷
title.set.value=設置值
warning.recalculate=將重新計算該值
warning.source.code.not.match=源碼與字節碼不匹配
action.add.field.watchpoint.text=添加字段觀察點
status.process.started=進程已啟動
status.process.terminated=進程已終止
status.disconnected=與目標 VM 斷開連接, 地址為: ''{0}''
status.stopped.at.cursor=在游標停止
status.line.breakpoint.reached=到達{0}({1}:{2,number,#})的斷點
status.line.breakpoint.reached.full.trace=到達{0}的斷點
status.generic.breakpoint.reached=已到達斷點
status.thread.blocked.by=線程{0}被線程{1}組織
status.thread.blocked.by.resume=<a href="#">恢復{0}</a>
status.breakpoint.reached.in.thread=線程{0}中到達的斷點
status.breakpoint.reached.in.thread.switch=<a href="#">切換線程</a>
status.method.entry.breakpoint.reached=方法''{0}''進入{1}({2}:{3,number,#})
status.method.exit.breakpoint.reached=已達到方法斷點. 方法''{0}''即將退出{1}({2}:{3,number,#})
status.field.watchpoint.reached.access='{'{0}@{5}'}'.{1}將在訪問{2}({3}:{4,number,#})
status.static.field.watchpoint.reached.access={0}.{1} 將在 {2}({3}:{4,number,#})下訪問
status.field.watchpoint.reached.modification='{'{0}@{7}'}'.{1}將被修改為{4}({5}:{6,number,#}). 當前值 = ''{2}''. 新值 = ''{3}''
status.static.field.watchpoint.reached.modification={0}.{1} 將在 {4}({5}:{6,number,#}) 下修改。當前值 = ''{2}''. 新值 = ''{3}''
status.connected=已連接到目標 VM, 地址: ''{0}''
status.connect.failed=無法建立與目標VM的連接, 地址: ''{0}''
error.debugger.already.listening=調試器已經在偵聽
transport.name.shared.memory=共享內存
transport.name.socket=套接字
error.debug.connector.not.found=無法使用傳輸''{0}''連接: 未找到所需的連接. 檢查您的JDK安裝.
error.no.debug.listen.port=未指定的監聽端口
error.no.debug.attach.port=要附加到未指定的端口
error.no.shmem.address=未指定共享內存地址
error.no.pid=未指定 Pid
debugger.jdi.bootstrap.error={0}. 請檢查您的JDK安裝.
warning.jdk140.unstable=調試程序的VM版本為"1.4.0".\nJ2SDK 1.4.0 記錄的錯誤可能會導致不穩定的調試器行為.\n我們建議使用J2SDK 1.4.0_01 或更高的版本.
title.jdk140.unstable=VM版本警告
message.remote.jre.version.mismatch=目標JRE版本 ({0})\n與項目JDK版本不匹配({1}), \n將使用JDK中的源: {2}
message.breakpoint.skipped=跳過的斷點在{0}, 因為它发生在調試器評估中
message.breakpoint.skipped.other.thread=已跳過 {0} 處的斷點，因為它发生在當前 JVM 外部
error.invalid.argument={0,choice, 1#無效參數|2#參數無效} 
error.vm.disconnected=VM斷開連接. 目標虛擬機關閉連接
error.unknown.host=無法連接到遠程進程。主機未知
error.unknown.host.with.address=無法連接到遠程進程。主機未知({0})
error.cannot.open.debugger.port=無法打開調試器端口
error.exception.while.connecting=連接到遠程進程的錯誤.\n異常事件: {0}\n異常消息: {1}
status.waiting.attach=調試器正在等待應用程序啟動
status.waiting.attach.address=調試地址: {0}
status.listening=監聽連接, 地址: ''{0}'', 傳輸: ''{1}''
status.connecting=正在連接到目標 VM, 地址: ''{0}''
status.app.running=應用程序正在運行
status.debug.stopped=調試已停止
status.waiting.evaluation.result=等待直到最后一個調試器命令完成
status.step.out=步出
status.step.into=步入
status.step.over=步過
status.run.to.cursor=運行到光標
status.process.resumed=恢復進程
status.paused.in.another.thread=在另一個線程中暫停
string.connection=''{0}''，傳輸: ''{1}''
error.pop.bottom.stackframe=無法彈出底部框架
error.pop.stackframe=彈出框架時发生錯誤: {0}
error.class.not.loaded=未加載類: {0}
string.file.line.position={0}中的類:{1}
string.null.context=上下文為null
evaluation.error.array.reference.expected=應為數組引用
evaluation.error.invalid.index.expression=索引表達式無效
evaluation.error.not.rvalue=分配的右邊部分不是一個值
evaluation.error.not.lvalue=分配的左邊部分不是一個值
evaluation.error.incompatible.types=''{0}''操作不兼容的類型
evaluation.error.lebeled.loops.not.found=沒有標記為''{0}''為循環語句
evaluation.error.variable.not.declared=變量''{0}''未聲明
evaluation.error.variable.already.declared=變量''{0}''已被聲明
evaluation.error.operation.not.supported=操作''{0}''不支持
evaluation.error.statement.not.supported=語句 ''{0}'' 不受支持
evaluation.error.incompatible.variable.initializer.type=''{0}'' 的初始值設定項具有不兼容的類型
evaluation.error.local.variable.missing.from.class.closure=在閉包類中找不到局部變量''{0}''
evaluation.error.local.variable.missing=找不到局部變量''{0}''
evaluation.error.cannot.resolve.field.class=無法解析包含字段''{0}''
evaluation.error.cannot.sources.for.field.class=找不到包含字段''{0}''的類的源
evaluation.error.identifier.expected=預期的標識符不是''{0}''
evaluation.error.cannot.evaluate.qualifier=無法評估限定符''{0}''
evaluation.error.invalid.array.dimension.expression=數組維度無效的表達式: {0}
evaluation.error.multi.dimensional.arrays.creation.not.supported=創建不支持的多維數組
evaluation.error.anonymous.class.evaluation.not.supported=不支持匿名類評估
evaluation.error.lambda.evaluation.not.supported=不支持Lambdas評估
evaluation.error.method.reference.evaluation.not.supported=不支持方法引用評估
evaluation.error.no.static.field=沒有此類 static 字段: ''{0}''
evaluation.error.no.instance.field=沒有此類實例字段: ''{0}''
evaluation.error.class.or.array.expected=在評估字段''{0}''時預期的類或數組類型
evaluation.error.evaluating.field=評估字段錯誤 : ''{0}''
evaluation.error.evaluating.method=評估方法錯誤 : ''{0}''
evaluation.error.object.reference.expected=應為對象引用
evaluation.error.no.stackframe=無法評估: 堆棧幀不可用
evaluation.error.no.static.method=沒有此類 static 方法: ''{0}''
evaluation.error.no.instance.method=沒有此類實例方法: ''{0}''
evaluation.error.array.type.expected=應為數組類型
evaluation.error.array.dimention.numeric.value.expected=數字值應為數組維度
evaluation.error.cannot.evaluate.array.initializer=無法評估數組初始值設定項
evaluation.error.incompatible.array.initializer.type=初始值設定項類型與數組的組件類型不兼容
evaluation.error.invalid.array.size=數組大小無效
evaluation.error.cannot.initialize.array=無法初始化數組
evaluation.error.cannot.evaluate.class.type=無法評估類類型
evaluation.error.cannot.resolve.constructor=無法解析構造函數 ''{0}''
evaluation.error.this.not.avalilable='this'是不可用的
evaluation.error.cannot.cast.null=不能將null轉換為''{0}''
evaluation.error.cannot.cast.numeric=不能將數字轉換為''{0}''
evaluation.error.cannot.cast.boolean=不能將布爾轉換為''{0}''
evaluation.error.cannot.cast.char=不能將字符轉換為''{0}''
evaluation.error.cannot.cast.object=不能轉換''{0}''為''{1}''
evaluation.error.numeric.expected=應為數值
evaluation.error.integer.expected=應為整數值
evaluation.error.boolean.expected=應為布爾值
status.invalid.breakpoint.out.of.class=斷點不屬于任何類
error.invalid.breakpoint.source.changed=源文件已更改或找到源文件與斷點的文件不對應
error.invalid.breakpoint.source.not.found=在項目類路徑中找到的類{0}沒有關聯的源文件
status.paused=已暫停
status.thread.monitor=監視器
status.thread.not.started=未啟動
status.thread.running=正在運行
status.thread.sleeping=正在休眠
status.thread.unknown=未知
status.thread.wait=等待
status.thread.zombie=僵停
status.thread.undefined=未定義
progress.hotswap.scanning.path=掃描: {0}
progress.hotswap.scanning.classes=掃描類以重新加載...
progress.hotswap.reloading=重新加載類...
error.operation.canceled=操作被取消
error.operation.not.supported.by.vm=虛擬機不支持的操作
error.class.def.not.found=找不到類定義 : {0}
error.verification.error=驗證錯誤 : {0}
error.unsupported.class.version=不支持的類版本 : {0}
error.class.format.error=類格式錯誤 : {0}
error.class.circularity.error=類循環錯誤: {0}
error.exception.while.reloading=重新加載類時出現異常 : {0} : {1}
status.hotswap.loaded.classes.up.to.date=已加載類是最新的. 不需要重新加載
error.io.error=I/O 錯誤
status.classes.reloaded={0,number}個類重新加載
status.classes.not.all.versions.reloaded=對于{0},{1}個類並非所有版本都重新加載
warning.range.too.big=指定范圍太大. {0} 需要太多的資源才能執行請求的操作. 你確定你要繼續嗎?
title.range.too.big=范圍太大了
error.array.renderer.configurable.start.index.less.than.zero=開始索引小于 0
error.array.renderer.configurable.end.index.less.than.start=結束索引小于開始索引
label.array.renderer.configurable.start.index=數組開始索引 (&R):
label.array.renderer.configurable.end.index=結束索引 (&D):
label.array.renderer.configurable.max.count1=顯示最大值 (&M)
label.array.renderer.configurable.max.count2=數組元素
label.base.renderer.configurable.autoscroll=自動定位到新的局部變量 (&L)
label.base.renderer.configurable.dfa.assist=基于數據流分析預測條件值和異常
label.base.renderer.configurable.show.synthetic.fields=合成字段 (&Y)
label.base.renderer.configurable.show.val.fields.as.locals=$val 字段作為局部變量(&V)
label.base.renderer.configurable.hide.null.array.elements=在數組和集合中隱藏空元素 (&N)
label.base.renderer.configurable.show.static.fields=static 字段(&S)
label.base.renderer.configurable.show.static.final.fields=static final 字段(&F)
label.base.renderer.configurable.show.declared.type=已聲明類型 (&T)
label.base.renderer.configurable.show.fq.names=完全限定名稱 (&Q)
label.base.renderer.configurable.show.object.id=對象ID (&I)
label.base.renderer.configurable.show.hex.value=顯示原函數的十六進制值
label.base.renderer.configurable.show.strings.type=顯示字符串的類型
label.base.renderer.configurable.populate.throwable.stack=自動填充可拋出對象的堆棧跟踪
label.base.renderer.configurable.alternate.view=啟用集合類的替代視圖 (&E)
label.base.renderer.configurable.enable.toString=啟用 't&oString()' 對象視圖 (&O):
label.base.renderer.configurable.all.overriding=對于覆蓋'toString()'方法的所有類
label.base.renderer.configurable.classes.from.list=對于列表中的類:
label.compound.renderer.configurable.show.type=顯示類型和對象id
label.compound.renderer.configurable.ondemand=按需
label.compound.renderer.configurable.use.default.renderer=使用默認呈現器
label.compound.renderer.configurable.use.expression=使用以下表達式:
label.compound.renderer.configurable.use.expression.list=使用表達式列表:
label.compound.renderer.configurable.apply.to=將呈現器應用于類型對象 (完全限定名稱):
error.compound.renderer.configurable.fqn.generic=不允許泛型類型
label.compound.renderer.configurable.when.rendering=渲染節點時
label.compound.renderer.configurable.when.expanding=展開節點時
label.compound.renderer.configurable.test.can.expand=測試一個節點是否可以擴展 (可選):
title.compound.renderer.configurable.choose.renderer.reference.type=呈現器引用類型
label.compound.renderer.configurable.append.default.children=追加默認子節點
button.add=添加
label.compound.renderer.configurable.table.header.name=名稱
label.compound.renderer.configurable.table.header.expression=表達式
label.compound.renderer.configurable.table.header.ondemand=按需
label.debugger.hotswap.configurable.hotswap.background=在后台重新加載類 (&B)
label.debugger.hotswap.configurable.compile.before.hotswap=在重新加載類之前構建項目
label.debugger.hotswap.configurable.enable.vm.hang.warning=開啟 'JVM將掛起' 警告
label.debugger.hotswap.configurable.reload.classes=編譯后重新加載類:
label.debugger.hotswap.configurable.always=總是(&A)
label.debugger.hotswap.configurable.never=從不 (&N)
label.debugger.hotswap.configurable.ask=詢問 (&K)
label.debugger.launching.configurable.disable.jit=關閉 JIT
label.debugger.launching.configurable.debugger.transport=傳輸:
label.debugger.launching.configurable.socket=&Socket 
label.debugger.launching.configurable.shmem=共享內存(&M)
label.debugger.general.configurable.show.alternative.source=顯示替代源切換器
label.debugger.general.configurable.kill.immediately=立即停止調試進程
label.debugger.general.configurable.always.debug=開始使用調試代理運行配置
label.debugger.general.configurable.enable.memory.agent=附加內存代理
label.debugger.general.configurable.enable.memory.agent.tooltip.text=Java 調試器將提供有關堆中對象的其他信息
label.debugger.general.configurable.always.smart.step.into=始終進行智能步入(&L)
label.debugger.general.configurable.skip.synthetic.methods=跳過合成方法 (&P)
label.debugger.general.configurable.skip.constructors=跳過構造函數 (&C)
label.debugger.general.configurable.skip.classLoaders=跳過加載器 (&O)
label.debugger.general.configurable.skip.simple.getters=跳過簡單的getter (&G)
label.debugger.general.configurable.step.filters.list.header=不要進入類 (&I)
label.debugger.general.configurable.evaluate.finally.on.pop=在彈出幀和早期返回值上評估 finally 塊:
label.debugger.general.configurable.evaluate.finally.always=總是(&A)
label.debugger.general.configurable.evaluate.finally.never=從不(&E)
label.debugger.general.configurable.evaluate.finally.ask=詢問(&K)
label.debugger.general.configurable.resume.only.current.thread=只恢復當前線程
label.threads.view.configurable.show.source.file.name=顯示源文件名
label.threads.view.configurable.show.class.name=顯示類名
label.threads.view.configurable.show.package=顯示軟件包名稱
label.threads.view.configurable.show.line.number=顯示行號 (&L)
label.threads.view.configurable.current.thread.on.top=將當前線程移動到頂部
label.threads.view.configurable.show.stack.frames.for.synthetic.methods=顯示合成方法的堆棧幀(&F)
label.threads.view.configurable.show.thread.groups=顯示線程組 (&G)
label.capture.configurable.capture.variables=捕獲局部變量 (可能會大大減慢執行速度)
label.capture.configurable.debugger.agent=檢測代理 (需要調試器重啟)
label.capture.configurable.annotations.configure=配置注解…
threads.view.configurable.display.name=自定義線程視圖
user.renderers.configurable.display.name=Java類型呈現器
async.stacktraces.configurable.display.name=異步堆棧跟踪
label.user.renderers.configurable.renderer.name=呈現器名稱:
text.user.renderers.configurable.no.renderers=沒有呈現器
button.copy=復制
user.renderers.configurable.button.description.copy=拷貝選擇的呈現器
threads.export.attribute.label.daemon=守護進程
threads.export.attribute.label.priority=prio={0}
threads.export.attribute.label.tid=tid=0x{0}
threads.export.attribute.label.blocks.thread=塊 {0}
threads.export.attribute.label.waiting.for.thread=等待 {0} 釋放鎖定 {1}
threads.export.attribute.label.locked=鎖定 {0}
threads.export.attribute.label.object-id=<0x{0}> ({1})
threads.export.attribute.error.incompatible.state=線程不兼容: 線程未掛起
label.generic.debugger.parameters.patcher.configurable.shmem=Shared &memory ()
label.generic.debugger.parameters.patcher.configurable.socket=套接字(&S)
button.debugger.settings=調試設置…
label.generic.debugger.parameters.patcher.configurable.transport=傳輸:
label.generic.debugger.parameters.patcher.configurable.shmem.address=共享內存地址:
progress.hot.swap.title=熱交換
status.hot.swap.completed.with.errors=Hot Swap 失敗.
status.hot.swap.completed.restart=<a href="restart">重新啟動調試會話</a>
status.hot.swap.completed.stop=<a href="stop">停止調試會話</a>
status.hot.swap.completed.with.warnings=Hot Swap完成並发出警告
label.generic.debugger.parameters.patcher.configurable.port=端口:
status.hotswap.uptodate=已加載類是最新的. 沒有什么可以重新加載.
add.instance.filter.dialog.title=添加實例過濾器
add.instance.filter.dialog.prompt=輸入實例ID:
add.instance.filter.dialog.error.numeric.value.expected=實例 ID 應為 'long' 類型的數值
filters.not.configured=未配置篩選器
hotswap.dialog.title.with.session=重新加載已更改的類 {0}
hotswap.dialog.title=重新加載已更改的類
hotswap.dialog.reload.action.text=重新加載
hotswap.dialog.run.prompt=一些類已經改變. 現在重新加載更改的類?
hotswap.dialog.hang.warning=JVM當前已被暫停.\n使用活動的第三方JVM代理重新加載類可能會導致JVM掛起.
label.add.field.breakpoint.dialog.fq.name=一個類的完全限定名稱:
label.add.field.breakpoint.dialog.field.name=字段名:
add.field.breakpoint.dialog.title=添加字段監視
add.field.breakpoint.dialog.classchooser.title=選擇字段的類
add.field.breakpoint.dialog.field.chooser.title={0,choice, 0#類沒有字段|1#選擇字段}
label.add.wildcard.breakpoint.dialog.method.name=方法名稱(&M):
label.add.wildcard.breakpoint.dialog.class.pattern=類模式(&C):
breakpoint.any.exception.display.name=任何異常
default.package.name=<默認>
class.filters.dialog.title=類過濾器
class.filters.dialog.inclusion.filters.group=包含
class.filters.dialog.exclusion.filters.group=類排除過濾器
instance.filters.dialog.title=實例過濾器
breakpoint.exception.breakpoint.display.name=''{0}''
exception.breakpoints.tab.title=Java異常斷點
field.watchpoints.tab.title=Java字段監視點
line.breakpoints.tab.title=Java行斷點
method.breakpoints.tab.title=Java方法斷點
method.breakpoints.slowness.warning=方法斷點可能會大大減慢調試速度
title.error.evaluating.breakpoint.condition=斷點條件錯誤
title.error.evaluating.breakpoint.action=斷點操作錯誤
error.evaluating.breakpoint.condition.or.action=處理虛擬機事件的問題:\n斷點: ''{0}''\n錯誤: {1}\n是否要在斷點處停止?
error.unable.to.evaluate.expression=無法評估表達式
error.unable.to.evaluate.capture.expression=無法評估捕獲鍵表達式: {0}
error.unable.to.evaluate.insert.expression=無法評估插入鍵表達式: {0}
breakpoint.properties.panel.option.pass.count=合格次數 (&P):
breakpoint.properties.panel.option.class.filters=類過濾器 (&L):
breakpoint.properties.panel.option.instance.filters=實例篩選器(&I):
breakpoint.property.name.pass.count=合格次數
breakpoint.property.name.class.filters=類過濾器
breakpoint.property.name.instance.filters=實例過濾器:
error.absent.exception.breakpoint.class.name=沒有異常斷點的類名
exception.breakpoint.console.message.location.info={0}:{1,number,#}
exception.breakpoint.console.message.location.info.absent=沒有調試信息
exception.breakpoint.console.message.with.thread.info={2}({3})處的線程 ''{1}'' 中发生異常 ''{0}''
exception.breakpoint.console.message={1}({2})處发生異常 ''{0}''
add.exception.breakpoint.classchooser.title=輸入異常類
label.exception.breakpoint.properties.panel.caught.exception=捕獲異常 (&N)
label.exception.breakpoint.properties.panel.uncaught.exception=未捕獲的異常 (&O)
label.exception.breakpoint.properties.panel.group.notifications=通知
error.invalid.breakpoint.missing.field.in.class=在類 ''{1}'' 中找不到字段 ''{0}''
status.breakpoint.invalid=無效
error.field.breakpoint.class.name.not.specified=無法添加監視點: 未指定類名
error.field.breakpoint.field.name.not.specified=無法添加監視點: 未指定字段名稱
error.field.breakpoint.field.not.found=無法為''{0}.{1}'' 創建字段監視點.\n字段 ''{2}'' 未找到
error.field.breakpoint.class.sources.not.found=無法為 ''{0}.{1}'' 創建字段監視點.\n沒有來源類''{2}''
label.filed.breakpoint.properties.panel.field.access=字段訪問 (&S)
label.filed.breakpoint.properties.panel.field.modification=修改 (&M)
label.group.watch.events=監視
error.failed.evaluating.breakpoint.condition=無法評估斷點條件\n''{0}''\n原因: {1}
error.invalid.breakpoint.no.executable.code=在類{1}中的行{0}處找不到可執行代碼
error.invalid.breakpoint.no.line.info=行號信息在類{0}不可用
line.breakpoint.display.name=行 {0}
line.breakpoint.display.name.with.class.or.method=行 {0,number,#} 在 {1}
error.invalid.breakpoint.method.not.found=在類{0}未找到方法
label.method.breakpoints.processing.classes=處理仿真方法斷點的類
label.method.breakpoints.setting.breakpoints=設置仿真方法斷點
label.method.breakpoint.properties.panel.method.entry=方法輸入 (&Y)
label.method.breakpoint.properties.panel.method.exit=方法退出 (&X)
label.method.breakpoint.properties.panel.emulated=仿真 (&U)
error.invalid.field.name=字段名無效 ''{0}''
label.unknown.value=<未知>
message.node.debug.info.not.available=調試信息不可用
message.node.local.variables.debug.info.not.available=變量調試信息不可用
message.node.local.variables.not.captured=局部變量未被捕獲用于合成,橋接等方法
message.node.local.variables.capture.disabled=局部變量未被捕獲,您可以更改它
message.node.array.elements.more=其他 +{0}
message.node.elements.null.hidden=不顯示空元素
message.node.all.array.elements.null=所有元素在范圍 ({0}, {1})都是空
message.node.all.elements.null=所有元素都為空
message.node.filtered=已過濾用:
message.node.empty.array=空
message.node.class.has.no.fields=類沒有字段
message.node.class.no.fields.to.display=沒有字段顯示
message.node.object.collected=對象在方法調用期間已被垃圾回收
message.node.thread.running=線程正在運行
message.node.thread.has.no.frames=線程沒有幀
message.node.evaluation.not.possible=目標虛擬機不被斷點請求暫停. 在這種模式下評估方法是不可能的
message.node.show.image=… 顯示圖片
message.node.show.icon=… 顯示圖標
message.node.navigate=… 導航
message.node.toString=… toString()
message.node.evaluate=…評估
label.thread.node.thread.collected=線程被垃圾收集
label.thread.node="{0}"@{1}: {2}
label.thread.node.in.group="{0}"@{1} 在組 "{3}": {2}
label.thread.group.node.group.collected=線程組 "{0}" 已被垃圾收集
label.thread.group.node=線程組 "{0}"@{1}
evaluation.error.invalid.type.name=類型名稱無效: ''{0}''
label.undefined=未定義
error.running.to.cursor.no.executable.code={0}沒有可執行代碼:{1}
evaluation.error.local.variable.declarations.not.supported=局部變量聲明不受支持.
evaluation.error.unsupported.declaration=聲明無效 : {0} 僅支持局部變量聲明.
error.jdk.not.specified=JDK未指定
error.field.not.found.in.class={1}中沒有此類字段{0}
error.breakpoint.file.not.found=文件 ''{0}'' 未找到; b此文件的斷點將被忽略
error.cannot.load.breakpoint.file=無法加載文件 ''{0}''; 此文件的斷點將被忽略
evaluation.error.invalid.this.expression=不能替換''{1}''的''{0}''為''this''
error.invalid.type.name=無效的類型名稱''{0}''
error.cannot.create.expression.from.code.fragment=無法從代碼段創建表達式.
error.invalid.local.variable.name=無效的局部變量名''{0}''
error.inconsistent.debug.info=不一致的調試信息
error.invalid.stackframe=內部異常 - 無效的堆棧幀
internal.debugger.error=內部錯誤。有關詳細信息，請參閱日志
error.text.invalid.port=未指定端口
title.smart.step.popup=進入的方法
action.watch.method.return.value.description=啟用觀察上次執行的方法返回值
action.watches.method.return.value.enable=顯示方法返回值
action.calculate.retained.size.info=''{0}'' 的保留對象高亮顯示
action.calculate.retained.size.title=''{0}'' 的保留大小
action.calculate.retained.size.text=''{0}'' 的保留大小為 {1}，淺層大小為 {2}
action.calculate.retained.size.waiting.message=正在計算保留大小…
action.watches.method.return.value.unavailable.reason=目標VM不支持的功能
action.auto.variables.mode=僅顯示執行點附近的變量
action.auto.variables.mode.description=僅顯示執行點附近使用的變量
frame.panel.frames.not.available=幀不可用于未掛起的線程
frame.panel.thread.finished=線程已結束執行
frame.panel.async.stacktrace=異步堆棧跟踪
error.corrupt.debug.info=調試信息可能已損壞: {0}
evaluation.error.unknown.method.return.type=無法解析方法返回類型: {0}
rule.name.group.by.class=按類分組
rule.name.group.by.package=按軟件包分組
error.context.has.changed=上下文已經改變，操作是不可能的
editor.notification.alternative.source=類{0}的替代來源
label.threads.view.configurable.show.prams.types=顯示方法實參類型
breakpoint.properties.panel.option.catch.class.filters=捕捉類過濾器:
breakpoint.properties.panel.option.caller.filter=調用方篩選器(&R):
caller.filters.dialog.title=調用方篩選器
settings.breakpoints.based=基于斷點:
settings.capture.column.capture.class.name=捕獲類名
settings.capture.column.capture.method.name=捕獲方法名稱
settings.capture.column.capture.key.expression=捕獲鍵表達式
settings.capture.column.insert.class.name=插入類名
settings.capture.column.insert.method.name=插入方法名稱
settings.capture.column.insert.key.expression=插入鍵表達式
settings.async.schedule=異步調度
settings.async.execute=異步執行
settings.async.annotations.configuration=異步注解配置
action.AnActionButton.text.duplicate=復制
action.AnActionButton.description.duplicate=復制
action.AnActionButton.text.enable.selected=啟用所選項
action.AnActionButton.description.enable.selected=啟用所選項
action.AnActionButton.text.disable.selected=禁用所選項
action.AnActionButton.description.disable.selected=禁用所選項
action.AnActionButton.text.import=導入
action.AnActionButton.description.import=導入
action.AnActionButton.text.export=導出
action.AnActionButton.description.export=導出
action.TurnOffDfaAssist.text=關閉數據流助手
action.TurnOffDfaAssist.description=為此會話關閉數據流輔助調試
warning.0=警告! {0}
instances.window.show.history=InstancesWindow.ShowHistory
select.stack.frame=選擇堆棧幀
tracing.class.filters=跟踪類篩選器
filters=篩選器…
export.failed=導出失敗
export.selected.capture.points.to.file=將所選捕獲點導出到文件…
import.capture.points=導入捕獲點
please.select.a.file.to.import=請選擇要導入的文件。
waiting.for.debugger.response=等待進程正常完成
thread.dump=線程轉儲
cancel.emulation=取消仿真
thread.operation.interrupt.is.not.supported.by.vm=虛擬機不支持線程操作 'interrupt'
add.stepping.filter=添加步進篩選器
method.name.not.specified=未指定方法名稱
class.pattern.not.specified=未指定類模式
add.method.breakpoint=添加方法斷點
if.the.value.is.referenced.by.a.constant.field=如果該值由 abstract 類的常量字段引用，IDEA 可以使用引用字段的名稱來另外標記從此類引用的所有值。
action.failed=操作失敗
label.object.markup.dialog.mark.referenced=標記從常量字段引用的值(&M)
debugger.data.views.configurable.show.title=顯示
overhead.toolwindow.title=開銷
memory.toolwindow.title=內存
checkbox.tracing=跟踪
enable.tracking.for.new.instances=啟用新實例的跟踪
condition=條件:
warning.filtering.may.have.side.effects=警告: 篩選可能有副作用
invoke.completion.once.more=再次調用補全以查看運行時類型變量
debugger.actions.group.title=調試器操作
surround.with.runtime.type.template=((RuntimeType)expr)
command.name.surround.with.runtime.cast=使用運行時轉換環繞
checkbox.start.tracing=開始
checkbox.stop.tracing=停止
checkbox.tracking.filters=篩選器
status.text.select.instance.to.see.stack.frame=選擇實例以查看堆棧幀
label.arrays.could.not.be.tracked=無法跟踪數組
status.text.no.stack.frame.for.this.instance=該實例沒有堆棧幀
label.capture.point.at={0}.{1} 的捕獲點
dialog.title.exception.to.throw=要拋出的異常
notification.method.has.not.been.called=尚未調用方法 <b>{0}()</b>
error.no.debug.process=無調試進程
error.context.not.available=上下文不可用
error.internal=內部錯誤
label.too.many.frames.rest.truncated=框架過多，其余框架將被截斷…
thread.dump.name=轉儲 {0}
error.unable.to.create.sapidattachingconnector=無法創建 SAPIDAttachingConnector
action.show.objects.text=顯示 {0} 對象…
progress.text.shown.x.of.y=已顯示: {0} / {1}
progress.text.errors.count=錯誤: {0}
progress.suffix.filtering.has.been.interrupted=(篩選已中斷)
progress.suffix.limit.has.been.reached=(已達到限制)
button.perform.reload.classes=執行重新加載類(&R)
button.skip.reload.classes=跳過重新加載類(&S)
call.tracer=調用跟踪器
label.instrumentation.tracker=檢測跟踪器: {0}
column.name.hits=命中
column.name.time.ms=時間(ms)
renderer.name={0} 呈現器
action.do.not.stop.if.called.from.text=從以下項調用時不要停止: {0}
action.stop.only.if.called.from.text=僅當從以下項調用時停止: {0}
action.stop.only.in.current.object.text=僅在當前對象中停止
action.stop.only.in.class.text=僅在類中停止: {0}
action.do.not.stop.in.class.text=不要在類中停止: {0}
dialog.title.return.value=返回值
process.attach.run.configuration.type.name=附加到進程
memory.view.constructor.tracker.name=MemoryViewConstructorTracker: {0}
capture.node.settings.link=\ 設置
array.filter.node.clear.link=\ 清除
breakpoint.variant.text.line=行
debugger.attach.group.name.java=Java
debugger.attach.group.name.java.read.only=Java 只讀
debugger.memory.agent.timeout.error=計算超時(堆過大，內存代理無法在合理時間內執行此操作，建議捕獲堆轉儲)
debugger.attach.password.for.sudo=輸入密碼以使用 su 權限連接: 
action.hide.text=隱藏
debugger.memory.agent.loading.error=無法將內存代理加載到虛擬機
evaluation.error.during.indexing=編制索引期間無法進行評估